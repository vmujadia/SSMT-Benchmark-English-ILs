दोस्तों, कृबु के सोलहवें मॉड्यूल में आपका स्वागत है। इस मॉड्यूल में हम फॉर्वर्ड स्टेट स्पेस प्लानिंग और बैकवर्ड स्टेट स्पेस प्लानिंग को देखेंगे। अब, ' प्लानिंग ' शब्द का उल्लेख पहले मॉड्यूल में कई बार किया गया है और इस मॉड्यूल में हम इस बारे में चर्चा करेंगे कि प्लानिंग से हमारा क्या मतलब हैं और फॉर्वर्ड स्टेट स्पेस प्लानिंग और बैकवर्ड स्टेट स्पेस प्लानिंग से क्या मतलब है और कभी-कभी इन्हें फॉर्वर्ड प्लानिंग और बैकवर्ड प्लानिंग भी कहते हैं। अब, शायद एक दिलचस्प निरिक्षण द्वारा यह बात आपके सामने आई है। हमने अब तक कई प्रोब्लम्स के बारे में बात की है, लेकिन सभी प्रोब्लम्स एक जैसे नहीं होते हैं। उदाहरण के लिए, अगर मैं एक सूत्र को सिध्द करना शुरू करता हूं और उसके बीच में, मुझे लगता है कि मैंने कुछ गलती कर दिया है तो मैं अब तक जो कुछ भी कर चुका हूं, उसे भूलकर फिर से शुरुआत कर सकता हूं। अब अगर मैं किसी वर्ड डॉक्यूमेंट को एडिट कर रहा हूं और कुछ बदल दिया, थोड़ी देर बाद मुझे लगता है कि मैंने जो भी किया, वह सही नहीं है। मुझे इसे किसी और तरीके से करना था, क्या मैं फिर से शुरू कर सकता हूं? आप ऐसा नहीं कर सकते, मैंने जो किया है उसे मुझे अंडू करना होगा लेकिन मैं अंडू कर सकता हूं। एक बार जब मैं इसे अंडू कर लेता हूं, मैं एक ऐसी जगह पर पहुंच जाता हूं, जहां मुझे कुछ अलग चाहिए, तो मैं यहाँ से आगे बढ़ सकता हूं और यह कर सकता हूं। मैं शतरंज खेल रहा हूं। मैंने दूसरी चाल में कुछ गलती की थी और अब मैं पंद्रहवीं चाल पर हूँ। मुझे एहसास होता है कि मैंने दूसरी चाल में कुछ गलती की थी, क्या मैं वापस जा सकता हूं और उसे सुधार सकता हूं, क्या मैं उसे अनदेखा कर सकता हूं? न तो मैं उसे नजरअंदाज कर सकता हूं, न ही मैं वापस जा सकता हूं। इसलिए तीन तरह की प्रोब्लम्स होती हैं। एक प्रोब्लम वह है जब आप एक सर्च स्पेस की खोज कर रहे हैं। इसके बीच में, आप बस यह भूल जाते हैं कि आप कहाँ थे, और फिर से शुरू करते हैं, कोई दिक्कत नहीं है। दूसरे मामले में, आप ऐसा नहीं कर सकते, लेकिन फिर भी आप वापस आ सकते हैं। आप सावधानी से उन चरणों को अंडू कर सकते हो जो आपने उठाए हैं और उस स्थान से शुरू कर सकते है जहां से आप मानते हैं कि गलती हुई है। तीसरे मामले में, आपके पास दोनों विकल्प नहीं है। आपको जो भी करना है उसे इसी स्थान से करना होगा। आप वापस नहीं जा सकते, आप अंडू या पूर्ववत नहीं कर सकते। तो, ये हुईं तीन प्रकार की प्रोब्लम्स। स्पष्ट रूप से कई मामलों में, आप देख सकते हैं कि तीसरी वाली प्रोब्लम सबसे कठिन है। अब, क्या आपके लिए उस कठिन प्रोब्लम को थोड़ी कम कठिन प्रोब्लम में बदलना संभव है? तीसरी वाली प्रोब्लम को दूसरी वाली प्रोब्लम में बदलना। इस युक्ति को प्लानिंग कहा जाता है। आप अपने हिसाब से योजना बना सकते हैं मैंने एक ऐसे मामले के बारे में बात की है जहाँ आप अपनी यात्रा की प्लानिंग कर रहे हैं या आप सचमुच में यात्रा कर रहे हैं। जब आप सचमुच में यात्रा कर रहे होते हैं, तो आप वापस जाकर पुनः आरंभ नहीं कर सकते हैं यह मैं पहले ही बता चुका हूं। तो, वास्तविक यात्रा तीसरी वाली प्रोब्लम है। आप वास्तव में ऐसा नहीं कर सकते हैं, कभी-कभी यह दूसरे प्रकार की प्रोब्लम होती है, आप वापस जा सकते हैं और फिर शुरूआत कर सकते हैं लेकिन फिर उस अतिरिक्त भार को आपको सहना होगा। इसलिए यदि आप शतरंज के मामले में प्लानिंग करना शुरू करते हैं, तो सबसे बड़ी बात है कि यह देखें कि आप क्या खेलेंगे, प्रतिद्वंद्वी की प्रतिक्रिया क्या होगी और आगे उस पर आपकी प्रतिक्रिया क्या होगी इत्यादि इत्यादि। उसके आधार पर आप अपनी चाल तय कर सकते हैं। इसलिए, प्लानिंग आपको इस चीज़ को बेहतर बनाने में मदद करती है। वैसे भी, कृबु प्रोग्राम्स के लिए प्लानिंग करना भी बहुत महत्वपूर्ण है। प्लानिंग किसी भी चीज के लिए महत्वपूर्ण है। लेकिन सोल्यूशन की प्लानिंग करने के लिए प्लानिंग करना बहुत ही उपयोगी है, क्योंकि जब आप विशेष रूप से तीसरी वाली जैसी प्रोब्लम्स के लिए किसी सोल्यूशन की पहले से प्लानिंग कर लेते हैं, तो यह आपको सबसे अच्छा रास्ता खोजने में मदद करती है क्योंकि इसमें आप ना तो वापस आने की स्थिति में होंगे और ना ही बाद के चरण में बेहतर रास्ता चुनने की स्थिति में। इससे पहले कि हम प्लानिंग करना शुरू करें, हमारे पास कुछ उद्देश्य होने चाहिए। अब, यह बहुत महत्वपूर्ण है क्योंकि प्लानिंग हमेशा उन उद्देश्यों पर आधारित होती है जिन्हें आप चुनते हैं। आइए एक शहर से दूसरे शहर का मार्ग खोजने का एक बहुत ही सरल उदाहरण लें। अब यदि आपका उद्देश्य लागत को कम करना है, तो आप साइकिल चुन सकते, क्योंकि यह सबसे अच्छा विकल्प है, लेकिन इससे उस शहर तक पहुंचने में दो घंटे लग सकते हैं फिर भी यह लागत प्रभावी है, सबसे अच्छा लागत प्रभावी सोल्यूशन है। यदि आप उपयोगकर्ता की सुविधा को अपने उद्देश्य के रूप में लेते हैं, तो आप यात्रा करने के लिए एक लक्जरी कार पसंद करेंगे या कोई अन्य व्यक्ति लागत के साथ-साथ लक्जरी को भी देखना पसंद करेगा। तब आप शायद दुपहिया गाड़ी पसंद करेंगे। इसलिए, अलग अलग उद्देश्यों के साथ प्लानिंग भी बदलती रहेगी। इतना ही नहीं, इस मामले में भी एक शहर से दूसरे शहर के लिए कई रास्ते हो सकते हैं। एक बहुत छोटा रास्ता है, लेकिन बहुत ही भीड़-भाड़ वाला। इसलिए, यदि आप कार से यात्रा करना चाहते हैं तो यह रास्ता बहुत अच्छा नहीं है। आप ऐसा रास्ता पसंद करेंगे, जो लंबा तो है, लेकिन कम ट्रैफ़िक वाला है। इसलिए, आपके अपने उद्देश्यों के आधार पर आपकी प्लानिंग बदलती रहेगी। इसलिए, उद्देश्य बहुत महत्वपूर्ण है। तो, उद्देश्य क्या हैं? वास्तव में, प्लानिंग के लिए आपको दो चीजें चाहिए होंगी। हम जो करना चाहते हैं, वह हमारे उद्देश्यों पर आधारित है और दूसरा, स्पष्ट रूप से, हम कैसे उस परिणाम तक पहुंचेंगे और आमतौर पर परिणाम क्या होता है, चालों का क्रम ही परिणाम है; चाल एक, चाल दो, चाल तीन, चाल चार और यदि आप पिछले मॉड्यूल को देखते हैं, तो इन्हें एक्शंस कहा जाता है। एजेंट एक्शंस लेता है। मूल रूप से, एक्शन एक नियम का कार्यान्वयन है लेकिन इसमें थोड़ा-सा अंतर भी है। मुझे, अभी अंतर के बारे में बात करनी है। जब मैं कहता हूं कि, शतरंज में एक मोहरा पहले से ही दो खाने चल चुका है या पहले से ही दो खाने आगे है, तो यह एक कथन और नियम है। इसलिए, जब नियम लागू किया जाता है तो आव्यूह , प्रोग्राम में बदलाव होता है। लेकिन वास्तविक हरकत भी होनी चाहिए। तो, एजेंट मूल रूप से यही करता है, यह उस मोहरे को आगे बढ़ाता है। इसलिए, वास्तव में एक्शन नियम को लागू करती है। तो यह नियम का कार्यान्वयन है। वास्तविक दुनिया में नियम कैसे लागू होता है इसे एक्शन द्वारा वर्णित किया जाता है। इसलिए, जब आप एक्शन लागू करना चाहते हैं, याद रखें, नियम और एक्शन काफी समान हैं। एक्शन सिर्फ इसका कार्यान्वयन है। यदि आप दिए गए स्टेट में किसी नियम या किसी एक्शन को लागू करना चाहते हैं, तो दो चीजों की आवश्यकता होती है। पहली चीज है पूर्वापेक्षा। अगर मैं उस मोहरे को आगे बढ़ाना चाहता हूं, तो आप जानते हैं कि दोनों अगले खाने खाली होने चाहिए, दोनों ही खानों में कोई अन्य मोहरा नहीं होना चाहिए। तो, यह पूर्वापेक्षा है। यदि पूर्वापेक्षा पूर्ण नहीं होती है, तो मैं यह नियम जनरेट नहीं कर सकता हूँ। इसलिए, अगर मैं जिस खाने पर जाना चाहता हूं, वह खाली नहीं है तो यह एक्शन संभव नहीं है। ठीक है, ताकि मैं ऐसा न कर सकूं। इसलिए, एक्शंस लागू होने के लिए पूर्वापेक्षा का मैच होना जरूरी है। वास्तव में, दूसरी महत्वपूर्ण चीज है। हमारे लिए कई एक्शंस उपलब्ध हो सकते हैं। जाहिर है, पहली आवश्यकता पूर्वापेक्षा है जहां एक्शन किसी भी दिए गए स्टेट में लागू होनी चाहिए। दूसरी चीज यह है कि एक्शन स्वीकार्य हो सकती है, लेकिन क्या वह एक्शन एक गोल प्राप्त करेगी या क्या यह मेरे स्टेट को गोल स्टेट के करीब ले जाएगी? अगर ऐसा होता है, तो बेहतर है। यह अधिक स्वीकार्य है। तो, यह दूसरी चीज है जिसके बारे में जानने में हमारी दिलचस्पी है। इसलिए कभी-कभी जब आपके पास कई एजेंट्स होते हैं, तब आपको एक एक्शन चुनने की आवश्यकता होगी जो हमें गोल स्टेट के करीब ले जाती है और ऐसी एक्शंस को रेलेवन्ट एक्शंस के रूप में जाना जाता है। और जब भी एक्शंस का क्रम होता है A एक, A दो, A तीन, A चार, A पांच, जब A एक लागू होता है तब वह A दो के लिए पूर्वापेक्षा जनरेट करता है। जब A दो को लागू किया जाता है, तब वह A तीन के लिए पूर्वापेक्षा जनरेट करता है और इसी तरह आगे चलता रहता है। ठीक है तो यह दूसरी आवश्यकता है और यहाँ एक उदाहरण भी है। उदाहरण के लिए, एक एजेंट जो एक इन्ट्रूश़न का पता लगाने में सक्षम है, एक स्टेट्स है जो कहता है कि डिनायल ऑफ सर्विस अटैक की संभावना है। अब, आपको इस स्टेट्स से आगे बढ़ना होगा और जब भी कोई संभावना हो तो उद्देश्य की पुष्टि करना भी इनट्रूशन डिटेक्शन एजेंट का एक उद्देश्य है। तो इसे एक स्टेट में जाना चाहिए जिसे बात की पुष्टि करना कहा जाता है। तो, इसे आगे बढ़ना चाहिए। दूसरा उद्देश्य स्पष्ट रूप से नेटवर्क में चल रहे अन्य आईडीएस एजेंटों से संपर्क साधना है, और तीसरा एक निवारक एक्शन लेना है। तो, ये तीन काम करने हैं। तो फिर यह क्या करता है? यह अटैक सीक्वन्स को जनरेट करता है मैं इसे अटैक रेसपोन्से सीक्वन्स कहूंगा, एक हमले की जांच करता है, दूसरा हमले की पुष्टि करता है और फिर निवारक एक्शन लेता है। अब, ये तीन एक्शंस होंगी। अब, आप देख सकते हैं कि ये तीनों एक्शंस केवल इसी क्रम में होंगी। आप केवल निवारक एक्शन ले लें और फिर कुछ कर दें, ऐसा नहीं हो सकता। आपको पहले उस हमले की पुष्टि करनी होगी। जिसके बिना आप काम नहीं कर सकते है। शतरंज में ऐसी चाल जो दो मोहरों को एक साथ चित्त कर सकती है का उपयोग करने के मामले का हैन्डाउट में वर्णन किया गया है। यहां दिलचस्प मुद्दा यह है कि न केवल हम प्लानिंग कर रहे हैं बल्कि प्रतिद्वंदी भी प्लानिंग कर रहा है। तो, जब हम कुछ कर रहे होते हैं तो प्रतिद्वंदी भी साथ-साथ कुछ कर रहा होता है। इसलिए, हमें यह सुनिश्चित करना है कि हमारी योजना ऐसी हो कि यदि प्रतिद्वंदी हमारी योजना को विफल करने वाली कोई भी योजना बनाता है, तभी हमें विरोधी से आगे जाकर सोचना होगा और यह काफी दिलचस्प काम है। इसलिए, प्लानिंग हमेशा सीधी-सादी नहीं होती है। जब शतरंज जैसे खेल में एक प्रतिद्वंद्वी शामिल होता है, तो हम इससे संबंधित कुछ मुद्दों को देख चुके हैं। जब प्रतिद्वंद्वी हमसे आगे की सोचता है, तो हम हारते हैं, ठीक है। इसलिए, यह यहाँ महत्वपूर्ण है। उद्देश्यों की एक नमूना सूची अगली स्लाइड पर दी गई है, जो प्रतिद्वंद्वी की पहुंच को न्यूनतम तक सीमित करने, किसी भी प्रणाली को बाधित करने और इत्यादि इत्यादि की बातें करती हैं। अब, विचार यह है कि जब मैं प्लानिंग कर रहा हूं,तब इन उद्देश्यों की पूर्ति होनी है। लेकिन सभी मामलों में, सभी उद्देश्यों को पूरा करना संभव है, आपको वास्तव में समझौता करना होगा। कभी-कभी कुछ उद्देश्य पूरे होते हैं और कभी-कभी कुछ उद्देश्य पूरे भी नहीं होते हैं। दो विकल्प हैं एक वैकल्प 90 प्रतिशत उद्देश्यों की पूर्ति होती है दूसरे में 80 प्रतिशत उद्देश्यों की पूर्ति होती है, अधिकतर ऐसा ही होता है। इसलिए, जब आप उद्देश्यों और एक्शंस को जोड़ने का प्रयास करते हैं तो हमारे एक्शंस को हमारे उद्देश्यों के साथ संरेखित होना चाहिए। उदाहरण के लिए, जब हमें पता चलता है कि यह दुर्भावनापूर्ण उपयोगकर्ता का आईपी एड्रेस है, तो हम जानते हैं कि इस दुर्भावनापूर्ण उपयोगकर्ता को ब्लॉक किया जा सकता है। अब आप बिना जाने ही किसी आईपी एड्रेस को ब्लॉक नहीं कर सकते। तो, उस क्रम का पालन किया जाना है। कोई पूर्वापेक्षा होने पर ही एक्शन ली जा सकती है। एक्शन केवल तभी संभव है जब उस पूर्वापेक्षा को जनरेट करने के लिए कोई एक्शन ली जाती है। उदाहरण के लिए, मैं एक हमलावर के आईपी एड्रेस को ब्लाक करना चाहता हूं मुझे कोई एक्शन लेनी होगी, जिससे मुझे वह आईपी एड्रेस मिले। तो, उन एक्शन्स को इस तरह सूचीबद्ध किया जाता है। अब, मुझे अच्छा लगता है जब हम स्टार्ट स्टेट से शुरू करते हैं और फिर हम गोल स्टेट तक पहुंच जाते हैं, हम लगातार यह सुनिश्चित करते हैं कि उद्देश्यों को संबोधित किया जाए। फिर दो अलग-अलग प्रकार के व्यवरोध होतें हैं। मैं उन्हें सॉफ्ट स्ट्रेंन्ट्स और हार्ड कंस्ट्रेंन्ट्स कहता हूं। और मैं इन चीजों को समझने के लिए अकादमी डोमेन से एक उपमा लेता हूं। एक टाइम टेबल तैयार किया जा रहा है। अब एक व्यवरोध यह है कि एक शिक्षक एक ही समय में दो कक्षाएं नहीं ले सकता है। अब, यह एक हार्ड कंस्ट्रेंन्ट है। आप इसका उल्लंघन नहीं कर सकते, आप चाहकर भी इसका उल्लंघन नहीं कर सकते हैं। लेकिन दूसरा व्यवरोध जिसे सॉफ्ट कंस्ट्रेंन्ट कहा जाता है, शिक्षक लगातार दो कक्षाएं नहीं ले सकता है। अब, यह एक अच्छी बात है कि यदि शिक्षक को लगातार दो कक्षाएं लेनी हैं, तो पढ़ाने का स्तर समान नहीं होगा। तो, आपको इससे बचने की कोशिश करनी चाहिए लेकिन ऐसा नहीं है कि शिक्षक ऐसा कर ही नहीं सकता। इसलिए इसे सॉफ्ट कंस्ट्रेंन्ट कहा जाता है जिसका आप कभी कभार उल्लंघन कर सकते हैं। तो, उद्देश्य भी उस प्रकार के होते हैं-उपयोगकर्ता की सुविधानुसार। उदाहरण के लिए, उपयोगकर्ता की सुविधानुसार एक ऐसा उद्देश्य है जिसे मुझे पूरा करना होगा। इसलिए, उपयोगकर्ताओं के लिए नेटवर्क धीमा हो या सर्वर एक्सेसबल ना हो और ऐसा कुछ भी लेकिन जब नेटवर्क पर कोई गंभीर हमला हो रहा है तो बेहतर है, आप कह सकते हैं कि उपयोगकर्ता की सुविधानुसार एक नगण्य विषय है, आप बस वही कदम उठाएं जो उस हमले को विफल करने के लिए आवश्यक हों। उपयोगकर्ता सेवा से थोड़ा असंतुष्ट रहे हैं, कोई हर्ज नहीं है। तो, उद्देश्य पर कम ध्यान दिया जाता है। तो यही होना चाहिए। तो, यह एक और मुद्दा है। आपको यह करना है कि हार्ड कंस्ट्रेंन्ट्स और सॉफ्ट स्ट्रेंन्ट्स दोनों का पता लगाएं और एक ऐसे मार्ग अपनाएं जो आपको दोनों प्रकार के व्यवरोधों का प्रबंध करने में मदद करता है। और उसके आधार पर आप तय कर सकते हैं कि आपका प्रदर्शन क्या होना चाहिए है। कई प्रकार की प्लानिंग्स हैं- सिम्पल प्लानिंग और डिटेल्ड प्लानिंग । सिम्पल प्लानिंग में आपको ज्यादा कुछ करना नहीं होता है। आप बस वर्णन करते हैं और यह तेजी से हो जाता है लेकिन मुद्दा यह है कि विवरण या डिटैलिंग में अलग हो सकता है और यह एक समस्या बन सकती है। डिटेल्ड प्लानिंग बेहतर है क्योंकि आपको लागू करते समय चिंता करने की आवश्यकता नहीं है, लेकिन फिर इसमें अधिक समय लगता है। ठीक है, लेकिन फिर अन्य मसले भी हैं। जैसे कि क्या दुनिया पूर्वानुमेय है। आप कहते हैं कि मैं इसे ऐसे करूंगा, जहां दुनिया इस तरह होगी। और फिर मैं एक और कदम उठाता हूं जैसे कि आप ताश खेल रहे हैं, आप कहते हैं कि मैं यह पत्ता खेलता हूं और फिर क्योंकि दूसरे भी खेलेंगे, मुझे एक और पत्ता खेलने की जरूरत होगी। अब, यह आपके हाथ में नहीं है। दुनिया पूर्वानुमेय नहीं है। सेल्फ-ड्राइविंग कार के मामले में, सबसे ज्यादा किस चीज का अनुमान लगाया जा सकता है? आप जानते हैं कि जब मैं ब्रेक लगाता हूं, तो वाहन की गति कम हो जाएगी और जब मैं एक्सेलरेटर दबाता हूं, तो वाहन की गति बढ़ जाएगी। तब, दुनिया पूर्वानुमेय है और मैं ज्यादातर मामलों में अपनी एक्शन के परिणाम का अनुमान लगा सकता हूं। तो, दुनिया निश्चित रूप से ऐसी है, लेकिन अगर आप एक एइट पज़ल मामले को लेते हैं तो दुनिया बहुत ही ज्यादा पूर्वानुमेय है। मैं एक्शंस का क्रम प्रदान कर सकता हूं और यह मुझे स्पष्ट रूप से बता सकता है कि मैं उत्तर पा सकता हूं या नहीं। कार चलाना बिल्कुल भी अनुमान लगाने योग्य काम नहीं है और ताश खेलना उसकी तुलना में लगभग अप्रत्याशित है। तीसरा या अगला मसला, दुनिया बदल रही है जबकि यह जानबूझकर हो रहा है अब आपके पास एक स्थिति है और आप अगला कदम उठाने के बारे में सोच ही रहे हैं और तब तक दुनिया बदल जाती है या नहीं। शतरंज के मामले में, आपके पास शतरंज बोर्ड है। प्रतिद्वंद्वी ने अपनी चाल चल दी है और अब आपको अपनी चाल चलनी होगी। लेकिन इससे पहले, आप कुछ समय के लिए सोच सकते हैं, दो मिनट, पांच मिनट, दस मिनट। दुनिया बदलने वाली नहीं है। दुनिया वैसी ही रहने वाली है। इसके विपरीत एक सेल्फ ड्राइविंग कार में, दुनिया बदल सकती है और यह वास्तव में बदलती है। यदि एक सेल्फ-ड्राइविंग कार को निर्णय लेने में पाँच सेकंड लगते हैं, मान लें अगर यह दायें मुड़ना चाहती है यह सब कुछ देखती है और दायें इंडिकेटर को शुरू करती है, दोयें आईने में देखती है वगैरह वगैरह और यह उस पर काम कर रही है और पांच सेकंड उस में बीत जाते हैं तो क्या वह फिर से ऐसा कर सकती है। जैसकि वास्तव में उसे दिशा बदलने से पहले दोयें आईने में देखना चाहिए। क्यों? क्योंकि दुनिया बदलती रहती है और हो सकता कि पिछले पांच सेकंड में संभव है कि वहाँ कोई और वाहन आ गया हो जो इस तरह से बीच में आ जाए कि अगर यह दायीं ओर मोड़ती है तो इसके साथ कोई दुर्घटना घट सकती है। तो, दुनिया बदल रही है। तो यह एक और मसला है। चौथा यह है कि क्या दुनिया पूरी तरह से दृश्यमान है या नहीं। कभी-कभी दुनिया सच में दृश्यमान होती है। शतरंज के मामले में दुनिया पूरी तरह से दृश्यमान है। अगर मौसम संबंधी कोई मसला न हो, तो सेल्फ ड्राइविंग कार वाले मामले में भी यह काफी हद तक दृश्यमान है। ताश वाले मामले में, दुनिया दृश्यमान नहीं है। आप वास्तव में उन पत्तों के बारे में नहीं जानते जो दूसरों के पास हैं। आप बस मान सकते हैं, अनुमान लगा सकते हैं और अपना काम कर सकते हैं। बस अनुमान लगाओ और काम करो। तो, उनमें से प्रत्येक के लिए आपको अलग-अलग प्रकार के प्लानिंग की आवश्यकता होती है और हम क्यों इसका उपयोग कर रहे हैं? मैं फिर से आपको बताता दूं कि हम एजेंट आधारित खोज के बारे में क्यों बात कर रहे हैं। एजेंट आधारित खोज दूसरी खोज के समान ही है जिसे हमने देखा है, लेकिन यह अधिक स्पष्ट और विस्तृत है। क्यों? क्योंकि जब मैं ग्राफ आधारित चीज में कहता हूं कि मैं एक दायां मोड़ ले रहा हूं तो मैंने दायां मोड़ कहा और हो गया। लेकिन दायां मोड़ असल में क्या है? एजेंट आधारित मामले में, यह कहता है कि दायां मोड़ लेने में एक एक्शन है, कुछ ऐसा, जो एक दायां मोड़ लेने के लिए किया जाना है। तो, उस विस्तृत प्रक्रिया का ब्योरा दिया जाता है। इतना ही नहीं, ऐसा कुछ है जो इसे लागू भी करता है। उदाहरण के लिए, यह कहता है कि यह ऐसा करने लिए स्टीयरिंग व्हील को घड़ी की सुई की दिशा में घुमाएगा। तो वह कलन विधि , वह प्रोसेस भी प्रदान किया जाता है। तो, इसमें मूल रूप से एक प्रोग्राम होता है जो उस एक्शन , उस नियम को लागू करता है, ठीक है, मैंने पहले ही बता दिया है कि एक एक्शन नियम को लागू करती है। तो, यहाँ एक उदाहरण है। जिससे हम और अधिक स्पष्ट हो जाते हैं। और जब हम उस प्लानिंग की योजना बनाते हैं, योजना बनाने के दो अलग-अलग तरीके होते हैं, एक तो अपना पिछला अनुभव,जो मेरे पास है उसके आधार पर प्लानिंग करना। उदाहरण के लिए, मुझे एक सम्मेलन के आयोजन की योजना बनानी है और मैं पहले ही बीस से तीस सम्मेलनों का आयोजन कर चुका हूं और मैंने जो कुछ इतने वर्षों में सीखा है उसका उपयोग मैं अगले सम्मेलन को आयोजित करने के लिए कर सकता हूं जिसे मैं आयोजित करने जा रहा हूं। यह संभव है कि अगली बार मुझे एक अंतर्राष्ट्रीय सम्मेलन आयोजित करना पड़े, जो मैंने पहले कभी नहीं किया है। लेकिन फिर मेरा अपना अनुभव, राष्ट्रीय सम्मेलन के आयोजन का आंशिक अनुभव मेरी मदद कर सकता है। मुझे एक ऐसा काम दिया जा सकता है, जिसे मैंने पहले कभी न किया हो और तब मुझे एक नये सिरे से उसे फिर से करना होगा। ठीक है, तो ये दो अलग-अलग मामले हैं। पहले वाले को मामला आधारित तर्क कहा जाता है। जब भी आपको कोई प्रोब्लम होती है, एजेंट के पास प्रोब्लम होती है। वह मामला आधारित तर्क दूसरा वाला है। मामला आधारित तर्क , तर्क वितर्क का एक बहुत ही सरल तरीका है। जब भी आपको कोई प्रोब्लम आती है, तो आप अपने डेटाबेस में देखते हैं। यदि कोई प्रोब्लम उस जैसी दिखती है, तब पहले वाले के लिए जो सोल्यूशन हमने निकाला था उसका पता लगाएं और उसे लागू करें। उदाहरण के लिए, मैं एक इनट्रूशन डिटेक्शन एजेंट हूं। तब मैं क्या करूंगा जब मेरा सामना एक नए हमले से होता है, मैं सिर्फ इस हमले की तुलना उन हमलों से करने की कोशिश करता हूं, जो मैं पहले देख चुका हूं। अगर मुझे वैसा ही हमला मिलता है, तो मैं पता करने की कोशिश करूंगा कि मैंने उस प्रोब्लम को हल करने के लिए क्या किया था और फिर मैं उसी प्रोसेस का अनुसरण करूंगा। लेकिन अगर एक नया मामला है, तो मुझे एक अलग दृष्टिकोण अपनाना होगा, आमतौर पर कुछ ऐसा जो मैं पहले से ही कर रहा हूं। मैं ह्यूरिस्टिक लागू करता हूं, मैं एक सर्च स्पेस जनरेट करता हूं और मैं उस सर्च स्पेस में घूमता हूं। उम्मीद है, मैं एक गोल स्टेट तक पहुँच जाऊँगा, ठीक है। मामला आधारित प्लानिंग को कभी-कभी मेमोरी-बेस्ड प्लानिंग के रूप में भी जाना जाता है क्योंकि इसमें काम पूरा हो जाता है। अब, अगली चीज जिसे हम देखने जा रहे हैं उसे फॉर्वर्ड प्लानिंग या फॉर्वर्ड स्टेट स्पेस प्लानिंग कहा जाता है। अब, आप क्या करते हैं, आप उस पर्सेप्ट सीक्वेंस को जनरेट करते हैं जो अंतिम अवस्था तक ले जाता है या अंतिम अवस्था तक ले जाने के लिए एक्शंस या एक्शंस का क्रम। मूल रूप से, किसी भी प्लानिंग का आउटपुट एक एक्शन सीक्वेंस होता है, फॉर्वर्ड या बैकवर्ड। फॉर्वर्ड रीज़निंग , आप एक्शन नंबर एक, दो, तीन, चार, पांच से शुरू करते हैं, यानि आप स्टार्ट स्टेट से शुरू करते हैं और एक गोल स्टेट तक पहुंचते हैं। एक बैकवर्ड रीज़निंग में, आप एक एक्शन n, n माइनस वन और इत्यादि से शुरू करते हैं यानि आप एक अंतिम अवस्था या उससे सिर्फ एक स्टेट पहले और इत्यादि से शुरू करते हैं और स्टार्ट स्टेट तक पहुंचते हैं। वैसे भी, यह ठीक है। लेकिन फिर एक्शंस , एक्शन का क्रम क्या होगा? ऐसी स्थिति में,जहाँ एक्शन A वन को एक्शन A टू से पहले घटित होना चाहिए। वहाँ इसे स्ट्रीक्ट ऑर्डरिंग कहा जाता है। उदाहरण के लिए, क्लच को दबाना और गियर को बदलना। अब, A वन को A टू से पहले घटित होना चाहिए। ठीक है, यदि आप ऐसा नहीं करते हैं, तो यह संभव नहीं होगा। तो यही स्ट्रीक्ट ऑर्डरिंग है। लेकिन एक एसी शुरू करना और एक्सेलरेटर के मान को बढ़ाना दो समानांतर चीजें हैं। ये एक दूसरे से संबंधित नहीं हैं, मैं इन्हें किसी भी क्रम में कर सकता हूं। यहाँ कोई क्रम नहीं है, बिना किसी क्रम के। लेकिन उसके बाद पार्शियल ऑर्डरिंग आता है। उदाहरण के लिए, मैं एसी शुरू कर सकता हूं या गियर बदल सकता हूं लेकिन फिर यह सब कार शुरू करने के बाद ही हो सकता है, जिसके बिना मैं ऐसा नहीं कर सकता। तो इसे पार्शियल ऑर्डरिंग कहा जाता है। यहाँ एक उदाहरण जिसे मैंने जानबूझकर चुना है और इसे पीपीटी पर दिखाया गया है, जो एक ऐसे मामले को इंगित करता है जहाँ बैकवर्ड रीज़निंग बेहतर है या बैकवर्ड स्टेट स्पेस प्लानिंग बेहतर है। अब आप उस आरंभिक अवस्था को देख सकते हैं और आप आरंभिक अवस्था से कई स्टेट्स जनरेट कर सकते हैं। लेकिन जिस अंतिम अवस्था को आप अभी देख रहे हैं, उससे आपको महसूस होगा कि कोई भी अंतिम अवस्था को आरंभिक अवस्था के चार अलग-अलग घटकों में बड़ी तेजी से परिवर्तित कर सकता है। क्योंकि यह ऐसा है इसलिए मैंने इस तरह से डिजाइन किया है। मैंने इस उदाहरण का निरूपण बैकवर्ड रीज़निंग की उपयोगिता दर्शाने के लिए किया है। इस मामले में, बैकवर्ड रीज़निंग काफी उपयोगी है। तो, कुछ संभावित चालें यहां दिखाई गई हैं। इसलिए, यदि आप स्टार्ट स्टेट से शुरुआत करते हैं, तो आप क्या कर सकते हैं, आप दो चीजें कर सकते हैं। एक शीर्ष पर से एक ब्लॉक उठाकर इसे टेबल पर रख सकते हैं, या आप इसे किसी अन्य स्टैक पर रख सकते हैं। शुरुआत में पांच स्टैक्स हैं। इसलिए, बहुत सारे विकल्प उपलब्ध हैं। पहली पंक्ति में G को टेबल पर रखने की बात की गई है, फिर D को और फिर C को रखने की बात की गई है। तो, सबसे ऊपर वाली चीजें हम टेबल पर रख रहे हैं। तो, यह एक चीज है। दूसरा, G को उठाकर, C के ऊपर रखना। आगे D को उठाकर किसी और के ऊपर रख देना। और आगे C को उठाकर इसे किसी और के ऊपर रख देना। तो, आप देख सकते हैं कि यहाँ बहुत सारे विकल्प उपलब्ध हैं। अगर आप पिछे या बैकवर्ड जाते हैं , तो ऐसा होने वाला नहीं है। पीछे की ओर जाने से, केवल एक ही स्टेट संभव है यानी A को फिर से टेबल पर रखना। और यही एकमात्र संभाव्य विकल्प है और यही कारण है कि यह बेहतर है क्योंकि आपके पास केवल एक ही विकल्प है। जब एक ही विकल्प होता है, तो आपको चुनने की आवश्यकता नहीं होती है और यह तेजी से काम करता है। और यह कभी कभी प्रशाखी घटक कहलाता है। आगे की दिशा में प्रशाखी घटक बहुत अधिक होता है। पीछे की दिशा में प्रशाखी घटक बहुत छोटा होता है। कभी-कभी बैकवर्ड प्लानिंग को लक्ष्य निर्देशित तर्क के रूप में भी जाना जाता है। लेकिन फिर आप कुछ कदम उठा सकते हैं। आपके लिए यह देखना बहुत जरूरी है कि क्या यह सही दिशा में है या नहीं। मैंने कहा कि मैं योग्य शब्द का उपयोग करता हूं। तो, कभी-कभी, आपको यह भी देखना होगा कि यह चाल योग्य है या नहीं। और यह ह्यूरिस्टिक नहीं है। कृपया इसे समझें, मैं अभी ह्यूरिस्टिक बारे में बात नहीं कर रहा हूँ। मान लें कि स्टार्ट स्टेट में कुछ एक घटक हैं। इस गोल स्टेट में भी कुछ घटक हैं। अब, जब आप आगे बढ़ते हैं, तो कुछ घटक होते हैं जो स्टार्ट स्टेट में हैं, लेकिन गोल स्टेट में नहीं हैं। कुछ घटक गोल स्टेट में हैं लेकिन ये स्टार्ट स्टेट में नहीं हैं। जब भी आप किसी एक्शन को लागू करते हैं, मान लें कि यदि वह एक घटक जोड़ता है जो कि गोल स्टेट में है और स्टार्ट स्टेट में नहीं है, तो यह अच्छा है। यह उस घटक को हटाता है जो स्टार्ट स्टेट में है और अंतिम अवस्था में नहीं है, यह भी अच्छा है। अब, इन दो महत्वपूर्ण बातों से संकेत मिलता है कि यह एक्शन करेंट स्टेट को एक ऐसे स्टेट में बदल देगी जो कि स्टार्ट स्टेट के मुकाबले गोल स्टेट के समीप होगा और इसे स्टार्ट स्टेट से गोल स्टेट की ओर ले जाएगी। अब, यह यहाँ महत्वपूर्ण है। यह एक चीज है, एक स्टेट की प्रासंगिकता एक और चीज है जिसके बारे में मैं बात करना चाहता हूं। दूसरा, यह है कि प्लानिंग उप घटकों की अंतर निर्भरता के बारे में अनभिज्ञ है। फिर यह जो भी मैंने चर्चा की है वह बहुत महत्वपूर्ण नहीं है, बहुत उपयोगी नहीं है। एक दिलचस्प उदाहरण चित्र में दिखाया गया है। B टेबल पर है, A टेबल पर है, C, D के ऊपर है, D टेबल पर है। अब आप चाहते हैं कि A, B पर हो, B, C पर हो और फिर D टेबल पर हो। अब, मैं क्या हासिल करना चाहता हूं, टेबल C पर, टेबल D पर, BA पर, AB पर। अब मैं यही चाहता हूं। अब इसमें से, मैं कहता हूं कि AB मेरा पहला घटक है। अगर मैं इसका उपयोग करके यह हासिल करने की कोशिश करता हूं, तो आप देख सकते हैं कि अगर मैं A को B के ऊपर पर रखता हूं, तो यह गोल स्टेट के निकट है, लेकिन यह गोल स्टेट नहीं है। वास्तव में मुझे इसे फिर से तोड़ना होगा। अब यह बहुत कुछ इसी तरह का है जिसे हमने लोकल ह्यूरिस्टिक फंक्शन और ग्लोबल ह्यूरिस्टिक फंक्शन पर चर्चा के समय देखा था। हालाँकि, मैं गोल स्टेट की ओर जा रहा हूँ पर इसे करने का यह सही तरीका नहीं है। तो, ये गोल्स आपस में जुड़े हुए हैं। तो, मैं जिस बारे में बात कर रहा हूं, प्रासंगिकता और घटक और सब कुछ, ये केवल तभी महत्वपूर्ण या उपयोगी हैं जब गोल्स अन्योन्याश्रित ना हों। सब गोल्स अन्योन्याश्रित नहीं हैं। यदि वे अन्योन्याश्रित हैं, तो मैं शायद AB को हल कर सकता हूं जो गोल स्टेट के लिए स्टार्ट स्टेट को निकट बनाता है। ठीक है, अगर मैं ऐसा करता हूँ, तो मैं गोल स्टेट तक नहीं पहुँचूँगा। अगली महत्वपूर्ण चीज यह है कि किसी दिए गए मामले में, मुझे किसका उपयोग करना चाहिए? मुझे फॉर्वर्ड रीज़निंग या बैकवर्ड रीज़निंग में से किसका उपयोग करना चाहिए? कहने के कई तरीके हैं, हम पहले ही प्रशाखी घटक के बारे में बात कर चुके हैं। यदि स्टार्ट स्टेट से एंड स्टेट तक का प्रशाखी घटक अधिक है तो हमें गोल स्टेट से कोशिश नहीं करनी चाहिए। लेकिन फिर अन्य विकल्प भी हैं। उदाहरण के लिए, इसे तय करने के अन्य वैकल्पिक तरीके। उदाहरण के लिए, यदि मैं आपको किसी ऐसी जगह पर जाने के लिए कहता हूं, जो आपके लिए अनजान है, ऐसी जगह से जो आपके लिए ज्ञात है जैसे आपका घर या आप उस अज्ञात स्थान से शुरू कर सकते हैं। हम में से अधिकांश लोग उस अज्ञात स्थान से शुरू करना पसंद करेंगे, क्योंकि यदि आप उस अज्ञात स्थान से किसी भी दिशा में यात्रा करते हैं तो आप एक ऐसी जगह पर पहुंचते हैं, जो आपको ज्ञात है। आप हमेशा इसे अपने घर से जोड़ सकते हैं। तो आप हमेशा वापस आ सकते हैं। इसका क्या मतलब है? यदि आप अपने होम स्टेट से शुरू करते हैं और पूरा करना चाहते हैं, तो आपको उस स्थान पर होना होगा जहां आप जाना चाहते हैं। क्योंकि, अनजान जगह पर आप यह नहीं जानते कि आप कहाँ से वहाँ पहुँचेंगे। इसलिए, आप वहाँ पहुँचे बिना यह नहीं जान पाएंगे कि आप गोल स्टेट में पहुँच गए हैं या नहीं। इसके विपरीत, जब आप किसी अज्ञात स्थान से शुरू करते हैं, तो विकल्पों की संख्या बहुत सारी होती हैं और ये सभी आपके लिए स्टार्ट स्टेट हैं। उदाहरण के लिए, यदि आप गोल स्टेट से शुरू करते हैं और मान लें कि आप दस, पंद्रह, बीस स्थानों पर पहुंचते हैं, जहाँ से आप अपने घर पहुँच सकते हैं, वहाँ बहुत सारे विकल्प उपलब्ध हैं। वो पंद्रह विकल्प संभव हैं। तो, आप उनमें से किसी एक तक जा सकते हैं और आप वहां पहुंच जाएंगे। इसलिए, जब ऐसा विकल्प और अधिक संख्या में विकल्प उपलब्ध हों, तो बेहतर होगा। दूसरा मुद्दा यह है कि किस प्रकार की प्रोब्लम का सोल्यूशन निकाला जा रहा है? उदाहरण के लिए, यदि आप एक बड़े डेटा को देख रहे हैं, पूछ-ताछ जो सामने आ रही है, पोस्ट की मात्रा को देखें और मुझे बताएं कि मेरा उत्पाद बिक रहा है या नहीं और जो भी हो। क्वेरी और बैकवर्ड प्रोसेस को समझने के लिए मैं वास्तव में क्या कर रहा हूँ। क्योंकि मैं क्वेरी से शुरू करता हूं। मुझे एक क्वेरी प्राप्त होती है। मुझे वापस प्रोसेस करना होगा। मैं शुरू से शुरुआत नहीं कर सकता। मैं वास्तव में नहीं जानता। या अगर मेरे पास शतरंज जैसा खेल खेलने का प्रोग्राम है, तो अब मैं अंतिम अवस्था से शुरू नहीं कर सकता। मुझे नहीं पता कि अंतिम अवस्था क्या होगी। मेरे पास यह जानने का कोई तरीका नहीं है, न केवल एक पारंपरिक शतरंज प्रोग्राम के लिए, बल्कि शायद रोज़मर्रा के अखबारों में आने वाली कई शतरंज की पहेलियों के लिए भी। उन मामलों के लिए भी, एक एकल स्टार्ट स्टेट होता है, लेकिन उनके लिए कई एंड स्टेट संभव होते हैं। इसलिए, हमेशा आरंभिक अवस्था या जो भी स्टेट आपको दिया जाता है, उससे शुरू करना बेहतर होता है। तो, मसला यह है कि इस मामले में, फॉर्वर्ड रीज़निंग बेहतर है। दूसरे वाला, यदि स्पष्टीकरण सुविधा की आवश्यकता होती है, अगर एजेंट को तर्क समझाने की आवश्यकता पड़ती है। उदाहरण के लिए, यदि आप एक स्वचालित टैक्सी लेते हैं और यह कहती है कि पाँच सौ रुपये, तो आप पूछ सकते हैं कि पाँच सौ रुपये क्यों। उसे वापस जाना होगा और पाँच सौ रुपये किस लिए यह समझाना होगा। जब कोई कहता है कि आम तौर पर मैं केवल चार सौ देता हूं और आप पांच सौ पूछ रहे हैं, ऐसा क्यों है? इसे वापस प्रोसेस करना होगा और इसके लिए कारण का पता लगाना होगा। इसलिए, जब भी स्पष्टीकरण की आवश्यकता होती है, तो एजेंट को गोल से प्लानिंग प्रोसेस को देखना होगा। ठीक है तो लक्ष्य निर्देशित तर्क या बैकवर्ड रीज़निंग इस मामले में बहुत ही महत्वपूर्ण है। अन्य मामलों में, सोल्यूशन कैसे लागू किया जाएगा? उदाहरण के लिए, यदि मैं सोल्यूशन को लागू करने के लिए प्रोलॉग का उपयोग कर रहा हूं। प्रोलॉग डिफ़ॉल्ट रूप से एक बैकवर्ड चैनिंग मेकैनिज़्म है। इसलिए, आमतौर पर आप अपना गोल प्रदान करते हैं, जब भी आप पहुंच जाते हैं, अपना गोल प्रदान करें और यह सोल्यूशन का पता लगाएगा। ठीक है, यह हमेशा पीछे की ओर यात्रा करेगा। इसलिए, यदि आप प्रोलॉग जैसी भाषा का उपयोग कर रहे हैं, तो सबसे अच्छा विकल्प वापस जाना है। यदि आप पारंपरिक भाषाओं का उपयोग कर रहे हैं, यदि आप जावा , C++, पायथन और उन जैसी का उपयोग करते हैं, जो शुरुआत से शुरू करना सबसे अच्छा तरीका है। इसका मतलब यह नहीं है कि आप पीछे की ओर से नहीं शुरू कर सकते हैं, लेकिन ऐसी प्रोग्रामिंग लैंग्वेज का प्राकृतिक प्रवाह आगे की दिशा में होता है। इसलिए, बेहतर है अगर आप इसी तरह से करें। ठीक है, तो मुद्दा यह है। इसके साथ हम फॉर्वर्ड रीज़निंग बनाम बैकवर्ड रीज़निंग , इस चर्चा के अंत में आ गए है, जिसे हमने अंत में देखा है। बहुत सारी ऐसी चीजें हैं जिन पर हमने चर्चा की है। हमने प्लानिं प्रोसेस को देखा, हमने प्लानिंग के घटकों को देखा, हमने देखा कि अच्छी प्लानिंग क्या होती है, हमने एजेंट बेस्ड प्लानिंग , प्रोब्लम्स, दुनिया, पर्यावरण से संबंधित मुद्दों और इत्यादि इत्यादि को भी देखा। और अंत में हमने फॉवर्ड रीज़निंग प्रॉसेस और बैकवर्ड रीज़निंग प्रॉसेस के फायदों और नुकसानों की तुलना की है। इन सब को देखते हुए, हम अब प्लानिंग प्रोसेस के बारे में बात करने के लिए तैयार हैं जो वास्तविक प्रोग्रामों में होती है। ठीक है, हम अगले मॉड्यूल में उस बारे में बात करेंगे। इसके साथ ही हम समापन करते हैं। धन्यवाद!
आपका स्वागत है दोस्तो! हम अभी AI के उन्नीसवें मॉड्यूल में हैं। अब हम खेल खेलने की कलन विधि के बारे में बात करेंगे। अनुसंधान के बेहद मांग वाले क्षेत्रों में से एक खेल खेलना है। और यह पैसा कमाने की दृष्टि से भी बहुत ही आकर्षक है। इसलिए बहुत सारे लोग इस दिशा में काम कर रहे हैं। खेल खेलना अपने आप में एक कृबु कार्यक्षेत्र है और हम इस बारे में बात करेंगे कि खेल खेलना कृबु कार्यक्षेत्र क्यों है और इसके क्या प्रोब्लम्स हैं और सोल्यूशन्स क्या हैं। इस मॉड्यूल में और बाद के कुछ मॉड्यूलों में हम इसके प्रोब्लमों और सोल्यूशनों को देखेंगे। ठीक है, हम खेल खेलने की कलन विधि के परिचय और उसके इतिहास और कुछ अन्य पूर्वापेक्षाओं के साथ शुरू करेंगे जो कि कोई भी खेल खेलना शुरू करने से पहले करना चाहेगा। व्यावसायिक क्षेत्र में बहुत अधिक सफलता और शोध है। यह बहुत दिलचस्प है। यह एक बहुत ही संरचित डोमेन है। इसका क्या मतलब है? एक संरचित डोमेन है क्योंकि हम स्टार्ट स्टेट के बारे में जानते हैं। हर एक खेल में, हम स्टार्ट स्टेट के बारे में बहुत स्पष्ट होते हैं। हम एंड स्टेट के बारे में भी बहुत स्पष्ट हैं। हम पहले ही शतरंज का उदाहरण देख चुके हैं। इतना ही नहीं, नियम बहुत ही संरचित हैं, क्योंकि लोग खेल रहे हैं, जीत रहे हैं और हार भी रहे हैं, ज्यादातर मामलों में नियमों को बहुत अच्छी तरह से परिभाषित किया गया है। किसी भी खेल को ले लें और उनके नियमों के बारे में आपके पास बहुत स्पष्ट विचार मौजूद है। तो यह तीसरी विशेषता है जो हमारे लिए बहुत महत्वपूर्ण है। लेकिन फिर ये मनुष्यों के साथ अन्योन्य क्रिया करते हैं। एक चेस प्लेईंग प्रोग्राम मानव के साथ अन्योन्य क्रिया करता है, एक कार्ड प्लेईंग प्रोग्राम भी मनुष्यों के साथ अन्योन्य क्रिया करता है, और हम चाहते हैं कि यह प्रोग्राम मानव की तरह काम करे और यहीं पर कृबु का काम शुरू होता है। ठीक है, आमतौर पर आपको दो प्रोब्लम्स आती हैं जो इस तरह के प्रोग्रामों से जुड़ी होती हैं। उनमें से एक को स्वीकार्य चाल जनरेटर कहा जाता है। शतरंज का उदाहरण लीजिए। जब आप शतरंज की बिसात को देखते हैं, तो सौइयों चालें संभव हो सकती हैं। लेकिन क्या आप सौ चालों के बारे में सोचेंगे? आप केवल पांच, छह, सात ज्यादा से ज्यादा दस चालों के बारे में सोचेंगे, उससे ज्यादा नहीं। आपने कैसे उन चुनिंदा चालों को चुना? वास्तव में हम नहीं जानते। लेकिन कुछ ऐसा है जो हम करते हैं। समय बीतने के साथ साथ हम यह कर रहे हैं। वास्तव में, एक स्ट्रक्चर्ड प्रोसेस होता है। यह न्यूरॉन्स की तरह नहीं है। एक स्ट्रक्चर्ड प्रोसेस है। जब आप शतरंज खेलना सीखते हैं, तो आप शायद हर नियम को याद रखना चाहते हैं जैसे कि वजीर को इस तरह से चलना चाहिए, एक हाथी को इस तरह आगे बढ़ना चाहिए और इत्यादि इत्यादि। तो यह स्वचालित रूप से नहीं होता है, लेकिन समय बीतने के साथ-साथ आप खेलने के नियम सीखते हैं और फिर अपने नियम बनाते है, अपके ह्यूरिस्टिक नियम। आप शतरंज खेलने में माहिर बन जाते हैं। इसलिए हमेशा की तरह इसमें बहुत सारा ह्यूरिस्टिक शामिल होता है, उदाहरण के लिए अगर कोई ऐसा खिलाड़ी है जो दो मोहरों को एक साथ चित्त करने वाली चाल को खेलने में माहिर है तो आपको चाहिए कि आप जब भी आप उसके साथ शतरंज खेलते हैं, तो आपको इसके बारे में पता होना चाहिए। हम बाद में दो मोहरों को एक साथ चित्त करने वाली चाल के बारे में सीखेंगे। बाद के मॉड्यूलों में हम उस पर भी चर्चा करेंगे। मुद्दा यह है कि हम उन नियमों को जनरेट करते हैं। ये नियम डोमेन ज्ञान पर आधारित हैं। इसलिए डोमेन ज्ञान के आधार पर, हम जानते हैं कि सौ नियमों में से केवल दस नियम महत्वपूर्ण हैं, दस चालें महत्वपूर्ण हैं और हम केवल उन पर ध्यान केंद्रित करते हैं, हम केवल उन नियमों की तुलना करते हैं और उनमें से सर्वश्रेष्ठ का चयन करते हैं। तो यह पहली चीज है जो हम करेंगे दूसरी बात यह है कि एक बार जब हम उन चीजों को लागू कर देते हैं और अंतत: हमें एंड स्टेट के कुछ विकल्प मिल जाते हैं। तब हम उन एंड स्टेट्स की तुलना करना चाहेंगे और यह पता लगाना चाहेंगे कि कौन सा एंड स्टेट हमारे लिए बेहतर है और हमें एक ऐसा रास्ता चुनना चाहिए जो हमें उस स्टेट में ले जाते हैं। एक और प्रकार का ह्यूरिस्टिक फंक्शन है, जिसे स्टैटिक इवैल्यूएशन फंक्शन कहा जाता है और इसे उन स्टेट्स पर लागू किया जाना है। स्टेट्स के स्टैटिक इवैल्यूएशन फंक्शन के मान को देखते हुए हम यह निर्धारित करने में सक्षम होंगे कि क्या स्टेट अच्छा है या बुरा। वह स्टेट कितना अच्छा है, क्या मुझे इस चाल के साथ आगे बढ़ना चाहिए या नहीं, जिसके परिणामस्वरूप यह स्टेट है, और इत्यादि। ये दो चीजें ऐसी हैं जो खेल खेलने के लिए बहुत ही महत्वपूर्ण हैं, लेकिन ये दोनों ही डोमेन ज्ञान पर आधारित हैं। ये अलग अलग खेल के लिए अलग अलग होती हैं, शतरंज के लिए यह किसी अन्य खेल से अलग होंगे। लेकिन फिर कुछ चीजें हैं जिनका आप सामान्यीकरण कर सकते हैं। उदाहरण के लिए, आप स्टेट स्पेस में कैसे घूम सकते हैं। अब यह उन उदाहरणों के समान नहीं है जिन्हें मैंने देखा है कुछ अंतर है जिन्हें हम उजागर कर देखने जा रहे हैं और देखें कि हम कैसे प्रबंध कर सकते हैं। लेकिन फिर उस खोज के हिस्से का बहुत आसानी से प्रबंध किया जा सकता है और यह किसी भी खेल के लिए स्वतंत्र होती है और हम बाद के मॉड्यूलों में उस पर ध्यान केंद्रित करेंंगे। जाहिर है कि खेल का लाभ उसके सटिक संरचित नियम होते हैं, जब भी आप वहां होते हैं तो आप किसी भी मोहरे को नियम के बिना हिला नहीं सकते हैं। उदाहरण के लिए, आपके पास एक हाथी है, इसके सामने हमारे पास एक और मोहरा है और जब तक कि यह मोहरा सामने है मैं इस हाथी को आगे नहीं बढ़ा सकता। ठीक है, मुझे इस मोहरे को हटाना होगा लेकिन नियम है कि मैं ऐसा नहीं कर सकता। वजीर को छोड़कर, कोई अन्य मोहरा आगे नहीं बढ़ सकता है। हम यह जानते हैं या यह नियम है? जाहिर है, यदि आप मानते हैं कि खेल खेलना सरल है। शतरंज कठिन है, लेकिन अगर आप कोई सरल खेल लेते हैं। यहां तक ​​कि टिक टैक टो में भी ज़िरो और क्रॉस नॉट और क्रॉस भी प्रोब्लम है यह भी इतना सरल नहीं है। यदि आपने इसके लिए प्रोग्राम लिखने की कोशिश की है, तो आप शायद महसूस करेंगे कि इसके लिए बहुत अधिक जटिलताओं की आवश्यकता होती है। और हम उस बारे में भी बात करेंगे। इस तरह की प्रोब्लम के साथ एक बड़ी प्रोब्लम यह है कि इसका क्रमचय और संचय बहुत बड़ा होता है और आपके लिए एक निश्चित समयावधि में संपूर्ण गेम ट्री का पता लगाना असंभव है। यह अच्छा भी है, क्योंकि यदि आप पूरी तरह से गेम ट्री का पता लेंगे, तो आपको पता होगा कि वास्तव में किस मार्ग का अनुसरण करना है। और एक बार जब आप वहाँ पहुँच जाएंगे तो आप जीत जाएंगे। आपको बिल्कुल पता होता हैं कि आप जीतने जा रहे हैं या नहीं, और फिर इस तरह खेलने में कोई मजा नहीं है। तो एक तरह से गेम प्लेईंग प्रोग्राम्स मजाक के लिए अच्छे हैं। वर्तमान युग में, मोबाइल और मल्टी एजेंट गेम्स भी भारी मांग में हैं। लेकिन फिर, एक बार जब हम इस सब का अध्ययन करेंगे, तो आप महसूस करेंगे कि यह भी उन खेलों के लिए एक अत्यंत महत्वपूर्ण घटक है। कुछ मुद्दे हैं, विशेष रूप से एक मुद्दा जिसे मैं उजागर करना चाहूंगा वह यह है कि यदि आपके पास एक मल्टी एजेंट गेम है, तो इससे संबंधित कई जटिलताएं मौजूद हैं। उदाहरण के लिए, यदि दो कारें रेस कर रही हैं। अब दो खिलाड़ी अपनी कार को चलाने के लिए एक ही लेन का उपयोग नहीं कर सकते। तो यह पहली चीज है। इसे सिंक्रोनाइज़ेशन या पार्क कहा जाता है। दोनों एक ही जगह पर पार्क नहीं कर सकते हैं। इसलिए, यह एक ऐसी प्रोब्लम है जो हम जो चर्चा करने वाले हैं उसके अतिरिक्त है, लेकिन अन्यथा सभी पारंपरिक खेल खेलने के मुद्दे ही हैं और हम जिस पर चर्चा करने जा रहे हैं, वह सभी के लिए प्रासंगिक है। स्वीकार्य चाल जनरेटर जिसके बारे में मैंने बात की थी, याद है जिसमें मैंने कहा था कि हमारे पास तकरीबन सौ चालें होती हैं और उनमें से हम केवल दस ही पर ध्यान देने वाले हैं। अब वह सब भी इतना सटीक नहीं है। यह बहुत ही डाइनैमिक भी है। इस अर्थ में डाइनैमिक कि यह पहले कई चीजों पर निर्भर करता है चाहे वह किसी खेल का शुरुआती भाग हो या फिर अंतिम भाग। आमतौर पर शुरुआती भाग हो या फिर अंतिम भाग आपको बहुत ज्यादा स्वीकार्य चाल जनरेटरों के बारे में चिंता करने की जरूरत नहीं है, लेकिन मध्य भाग के लिए जरूरत है। दूसरा खेल की गंभीरता है। मान लीजिए आपके राजा पर हमला हो रहा है। यदि राजा पर हमला हो रहा है, तो आपको कई चालों के बारे में सोचना होगा। आप केवल दस पर ही ध्यान केंद्रित नहीं कर सकते हैं आपको इसके लिए कई अन्य चालों के बारे में सोचना होगा। यह गंभीर स्तिथी है और इत्यादि इत्यादि। इसलिए, ऐसे कई मुद्दे हैं जो आपको यह तय करने देते है कि किस प्रकार के स्वीकार्य चाल जनरेटर का उपयोग किया जाना चाहिए और यह कितना घना होना चाहिए। स्पार्स नेबरहुड और डेंस नेबरहुड के बारे में हमारी चर्चा याद है? यहां पीएमजी भी इसी तरह से काम करता है। आम तौर पर, यह स्पार्स नेबरहुड का उपयोग करता है, लेकिन एक गंभीर स्थिति में यह डेंस नेबरहुड फंक्शन का भी उपयोग करता है। लेकिन एक और महत्वपूर्ण बात है, मैं यहाँ स्वीकार्य चाल जनरेटर और वैध चाल जनरेटर के बीच के अंतर को भी उजागर करना चाहूंगा। एक वैध चाल इसलिए मान्य होती है क्योंकि आप इसे खेल सकते हैं। स्वीकार्य चाल एक मान्य चाल जरूर है, लेकिन यह किसी भी फायदे की नहीं है। हम इसकी खोज नहीं करेंगे। उदाहरण के लिए, आगे बढ़ना एक वैध चाल है, लेकिन यह हमारे मामले में किसी भी काम की नहीं है तो इसे खेलने या करने का क्या फायदा है। इसलिए स्वीकार्य चाल जनरेटर उन चालों का पता नहीं लगाएगा। इसलिए सभी संभव चालें वैध चालें हैं। स्वीकार्य चालें केवल वे चालें हैं जो वर्तमान स्थिति में उचित होती हैं। एक और चाल है जिसे विजेता चाल कहा जाता है। विजेता चाल हमें जीत दिलाती है। अब यह एक महत्वपूर्ण श्रेणी है क्योंकि हम चाहते हैं कि उन स्वीकार्य चाल जनरेटरों में से विजेता चालें बाहर निकले। स्वीकार्य चालों से हार का सामना करना पड़ सकता है। हम स्वीकार्य चाल जनरेटर की सूची से एक चाल उठा सकते हैं लेकिन फिर हम हार जाते हैं। ऐसा हो सकता है। लेकिन विजेता चालें फिर से, एक सबसेट हैं। तो वैध चालें , इसका सबसेट स्वीकार्य चालें हैं, जिनका सबसेट विजेता चालें हैं। स्वीकार्य चाल जनरेटर का लाभ यह है कि हम अधिक गहराई से जांच कर सकते हैं क्योंकि अगर हमारे पास विचार करने के लिए सौ विषम चालें हैं और यदि आप के पास पांच छह मिनट या कुछ समय है, तो हमारे पास तलाशने के लिए सौइयों विकल्प हैं। तो हम बहुत आगे नहीं जाएंगे। लेकिन अगर यह घटकर दस रह जाता है, तो हम थोड़ा आगे तक जा सकते हैं। व्यावसायिक शतरंज के प्रोग्राम्स पंद्रह, बीस प्लाईज तक, पंद्रह बीस लेवलों तक जाते हैं। अब यह बहुत बड़ी बात है, क्योंकि ये इस स्वीकार्य चाल जनरेटर का उपयोग करते हैं। यदि स्वीकार्य चाल जनरेटर का उपयोग नहीं किया जाता है, तो यह संभवत: दो तीन लेवलों तक ही सीमित रहेगा या ज्यादा से ज्यादा पांच तक जा सकता है। एक और दिलचस्प बात यह है कि मैं खेल के प्रारंभिक और अंतिम भाग के बारे में बात कर रहा था। फिर से, क्योंकि हमारे पास शतरंज सहित अधिकांश खेलों में समय सीमा होती है, हम उन हिस्सों को तेजी से खत्म करना चाहते हैं, प्रारंभिक भाग और बाद के भाग को, जिसे हम एक सरल दाँव खेल कर सकते हैं। हम तय करते हैं कि किसी दी गई चाल के लिए यह एक सबसे अच्छी चाल है और इसे डेटाबेस में संग्रहीत करना है। हम कुछ भी नहीं करते हैं हम ना ही खोज का उपयोग करते हैं और ना ही हम ह्यूरिस्टिक का या किसी और का। हम जानते हैं कि यदि खिलाड़ी और यदि आपने किसी शतरंज के चैंपियन को शुरुआती भाग में खेलते देखा है, तो आपने शायद देखा होगा कि वे कितनी तेजी से खेलते हैं। वे अपने मोहरों को बहुत तेजी से आगे बढ़ाना शुरू करते हैं, वे इसे तेजी से करना चाहते हैं क्योंकि शुरुआती खेल में आप जानते हैं कि यदि प्रतिद्वंद्वी यह चाल चल रहा है, तो मुझे वह चाल चली होगी और वगैहरे वगैहरे। यह बहुत मुश्किल नहीं है। तो, उस चीज़ को एक डेटाबेस में संग्रहीत किया जाता है। प्रारंभिक भाग को डेटाबेस में संग्रहीत किया जाता है और इस चीज को बुक मूव के रूप में जाना जाता है। उस चाल को डेटाबेस में संग्रहीत किया जाता है। इसलिए जब भी प्रतिद्वंद्वी इसे खेलता है, आप डेटाबेस से उस चीज का मेल करते हैं और उसे जनरेट करते हैं। बुक मूवज बहुत सारी हो सकती हैं। लेकिन फिर एक फायदा भी है। आप बस इस खोज को आगे बढ़ाते हैं और दूसरी चीज काम कर जाती है। ये शतरंज की शुरुआत और अंतिम हिस्से में काफी उपयोगी होती हैं और उनमें से ज्यादातर का वास्तव में उपयोग किए जाता हैं। आप खेल के मध्य भाग में बुक मूवज का उपयोग नहीं कर सकते हैं क्योंकि हम जानते हैं कि हमारे पास खेल में प्रशाखी घटक औसतन पैंतीस हैं और एक खिलाड़ी औसतन एक खेल में पचास चालें खेलता है। दोनों खिलाड़ियों को देखते हुए आपके पास कुल पैंतीस घातांक सौ संभव चालें हैं। अब आप वास्तविक समय सीमा में उस सर्च स्पेस का पता नहीं लगा पाएंगे। इसलिए यह हमारे लिए असंभव है। या फिर आप इसे संग्रहीत भी नहीं कर पाएंगे। आप इसे संग्रहीत करने के लिए डेटाबेस भी नहीं रख सकते हैं। अंतिम डेटाबेस को प्राप्त करना लगभग असंभव है। और उस डेटाबेस में खोज करना भी बहुत महंगा है। तो, यह बिल्कुल असंभव है। इसलिए आप बीच के खेल में बुक मूवज का उपयोग नहीं कर सकते हैं। उन्हें केवल शुरुआती और अंतिम खेल में उपयोग किया जाता है। जैसा कि मैंने कहा, एक और चीज है स्टैटिक इवैल्यूएशन फंक्शन नामक ह्यूरिस्टिक फंक्शन । जिसका उपयोग किया जाता है। हम ऐसा करते हैं कि दिए गए बिंदु से जितनी दूर हो सके ट्री का पता लगाते हैं और वापस आकर एक चाल चुनते हैं। मान लें कि आपके पास चार अलग-अलग विकल्प हैं, हम हर एक की खोज करने की कोशिश करते हैं और देखते कि यह क्या प्रदान करता है फिर सबसे अच्छा नोड चुनते हैं। यह एक सामान्य प्रोसेस है। अब हम गेम प्लेईंग प्रोग्राम्स के इतिहास के बारे में थोड़ी बात करते हैं। क्लाउड शैनन ने लंबे समय पहले, उन्नीस सौ पचास में गेम प्लेईंग प्रोग्राम्स के बारे में बात की और फिर एलन ट्यूरिंग ने यह भी कहा कि चेस प्लेईंग प्रोग्राम बनाना और उस प्रोग्राम का विवरण प्रदान करना भी संभव है। उन्होंने खुद इसे बनाने की कोशिश नहीं की। सैमुअल्स ने उन्नीस सौ साठ में चेकर्स प्रोग्राम बनाया। और वह चेकर्स प्रोग्राम ड्राफ्ट गेम या चेकर्स गेम खेला करता था। वह खेल वास्तव में एक अच्छा उदाहरण था कि कोई गेम प्लेईंग प्रोग्राम को कैसे डिजाइन कर सकता है। उस प्रोग्राम की विशेष क्षमता थी अनुभवों से अपने दम पर सीखना। यह अंततः इतना अच्छा हो गया कि यह वास्तव में अपने आविष्कारक सैमुअल को ही हरा सकता था। लंबे समय पहले, उन्नीस सौ नवासी में आईबीएम के एक संगणक , डीप थॉट ने उस समय के ओलंपिक चैंपियन रिचर्ड लेवी को हराया। फिर उन्नीस सौ छियानवे में डीप ब्लू ने गैरी कास्पारोव, उस समय के विश्व चैंपियन को तीन दो के अंतर से हरा दिया। उन्होंने पांच खेल खेले, जिसमें से डीप थॉट टू ने तीन खेल जीते, दो गैरी कास्पारोव ने और फिर एक्स थ्री डी फ्रिट्ज नामक एक और प्रोग्राम था। यह भी गैरी कास्परोव के साथ हाल ही में दो हजार तीन में खेला, तुलनात्मक रूप से हाल ही में, यह तेरह साल पहले की बात है। लेकिन यह अभी भी बाकियों की तुलना में काफी हाल ही की बात है। तो इसने गैरी कास्परोव के साथ ड्रॉ किया। तो यह फिर से एक उत्कृष्ट उदाहरण था। यह इतिहास में है। स्टैनफोर्ड यूनिवर्सिटी को इतनी दिलचस्पी है, ये एक प्रोग्राम चला रहे हैं, वे एक खेल खेलने का प्लेटफॉर्म प्रदान करते हैं जहां लोग उस प्लेटफॉर्म का उपयोग कर अपने खेल बना सकते हैं। और फिर वे प्रतिस्पर्धा करते हैं और दो हजार पांच तक वे एक प्रतियोगिता चला रहे थे जहां लोग अपने प्रोग्राम को लिखकर उसका प्रोग्राम का प्रदर्शन कर सकते थे और अंत में प्रतियोगिता का आयोजन कर उस प्रतियोगिता के विजेताओं की घोषणा करते थे इत्यादि। अब बहुत सारे मल्टी एजेंट गेम्स भी इंटरनेट पर हैं। लेकिन हम आगे बढ़ने इससे पहले, हम एक और महत्वपूर्ण बात पर गौर करना होगा। हम किस प्रकार के खेलों के बारे में बात करने में रुचि रखते हैं? खेलों को वर्गीकृत करने के कुछ तरीके हैं। हमारे पास एक एकल व्यक्ति खेल हैं, जिसका सालिटेर एक उदाहरण है। दो-व्यक्तियों का खेल जैसे शतरंज। अनेक व्यक्तियोंं का खेल, मल्टी प्लेयर गेम जिसका कार रेसिंग एक और उदाहरण है। अंतर करने का यह एक तरीका है। एक और तरीका है कि क्या खेल ज़िरो सम है। ज़िरो सम गेम एक ऐसा खेल है जिसमें एक का लाभ ही दूसरे का नुकसान होता है। इसलिए अगर मुझे कुछ मिलता है, तो कोई और खो देता है। कई ताश के खेल ऐसे हैं। अगर मुझे ज्यादा हाथ मिलेंगे, तो दूसरी पार्टियों को कम मिलेंगे। तो ऐसे खेलों को ज़िरो सम गेम्स कहा जाता है। कुछ खेलों में, ऐसा नहीं होता है। उदाहरण के लिए, कार रेसिंग में, अगर मैं किसी और के साथ टकराता हूं, तो हम दोनों अंक खो देते हैं, ठीक है। मेरा नुकसान उसका लाभ नहीं है या कुछ मार्केटिंग गेम्स जहां हम में से कई के लिए लाभ संभव है। यदि सब कुछ ठीक है, हर कोई अच्छा खेल रहा है, तो प्रत्येक को लाभ मिलेगा यह एक उदाहरण है। तीसरा तरीका, अंतर करने का तीसरा तरीका है कि क्या खेल के बारे में पूरी जानकारी उपलब्ध है। ताश के खेल में आपके पास पूरी जानकारी नहीं होती है। अब आप समझ सकते हैं कि यह एजेंटों के बारे में चर्चा के समान है जो हमने पहले की थी और यह सच है। पूर्ण जानकारी वाले खलों को प्रोग्राम करना आसान है। अधूरी जानकारी वाले खेलों के लिए अनुमान लगाने और अनुमानों को उलटने की आवश्यकता होती है। इसके लिए एनएसआरएस इत्यादि की जरूत होती है, जिसके बारे में हमने बात की है, वह सामने आएगा, जो समय के साथ-साथ संग्रहित करने के लिहाज से भी काफी महंगा है। पूरी जानकारी में परिवेश भी शामिल है। यह बात करता है, उदाहरण के लिए एक कार रेसिंग खेल में अन्य लोग क्या कर रहे हैं, वह जानकारी भी आपके पास उपलब्ध होती है। अगर वह आपके पास उपलब्ध है तो आप कार रेसिंग में अच्छा प्रदर्शन कर पाएंगे। यदि आप नहीं जानते कि दूसरे क्या कर रहे हैं, तो शायद आप नहीं कर पाएंगे। संभवतः आप टकरा पाएंगे आप जल्द ही किसी और से टकरा जाएंगे। इसलिए पूरी जानकारी वाले खेल तुलनात्मक रूप से बेहतर होते हैं लेकिन अधूरी जानकारी वालों में, जब आपके पास पूरी जानकारी नहीं होती है जैसा कि मैंने कहा था आपको अनुमान वगैरह लगाने की जरूत होती है, तो यह इसे थोड़ा कठिन बनाता है। अंतर करने का अंतिम तरीका यह है कि क्या यह निश्चयात्मक है। उदाहरण के लिए अगर मैं एक चाल चलता हूं, तो क्या मैं यह कह सकता हूं कि अगर मैं यह चाल चलता हूं तो मुझे सुनिश्चित रूप से यह परिणाम मिलेगा? अगर मुझे यकीन नहीं है, यह निश्चयात्मक नहीं है। यदि यह निश्चित है, तो यह निश्चयात्मक है। उदाहरण के लिए, मैं एट पज़ल खेल रहा हूं, मैं एक स्लाइड नीचे ले जाता हूं, मुझे पता है कि वास्तव में क्या होगा या अगर मेरे पास कुछ चालों की श्रृंखलाएं हैं, कुछ एक्शंस की श्रृंखलाएं हैं, तो मैं आउटपुट की गणना कर सकता हूं और मेरे पास वही आउटपुट होगा जो बदलने वाला नहीं है। कार ड्राइविंग के मामले में या शतरंज में भी आपके पास यह नहीं हो सकता है। तो ये निर्धारण के बारे में मुद्दे हैं, क्योंकि शतरंज में यह कार रेसिंग की तुलना में थोड़ा अधिक निश्चयात्मक है। क्यों? क्योंकि इसके लिए केवल प्रतिद्वंद्वीयों की उस चाल को जानने की जरूरत होती है। लेकिन आपके मामले में आप जानते हैं कि वास्तव में क्या होने वाला है। यदि प्रतिद्वंद्वी आपकी उस चाल के अनुसार नहीं चल रहा है, तो वह हिस्सा बदल जाएगा। लेकिन आप जानते हैं कि जब मैं एक मोहरे को आगे रखता हूं तो यह आगे बढ़ता है। ठीक है तो अब ये आपके हाथ में है। तो वह हिस्सा निश्चयात्मक है। कार के मामले में ऐसा नहीं है। कार रेसिंग में आप एक्सीलरेटर पेडल दबाते हैं लेकिन शायद यह काम न करे क्योंकि आप पहले ही अधिकतम सीमा तक पहुँच चुके हैं। तो यह बिल्कुल भी निश्चयात्मक नहीं है। इतना ही नहीं आप ऐसा इसलिए भी नहीं कर सकते क्योंकि इसमें बहुत से अन्य खिलाड़ी भी शामिल हैं। तो यह निश्चयात्मक नहीं है। जाहिर है कि आपको इस मामले में कुछ धारणाएं अपनानी होंगी। दो खिलाडी वाले खेल के मामले में, हम यहाँ क्या करने जा रहे हैं या हमारे मामले के लिए हम एक दो खिलाडी वाले खेल को लेंगे। सभी बाद वाले मॉड्यूलों में हम केवल दो खिलाडी वाले खेल और संपूर्ण जानकारी वाले खेल की धारणा के साथ ही वर्णन करेंगे। हम उस हिस्से को नहीं देखेंगे। वह हिस्सा थोड़ा और मुश्किल है। जैसा मैंने कहा है हमें उन धारणाओं और उस चीज़ की आवश्यकता है। इस के अंत में जब हम मशीन लर्निंग के बारे में बात करेंगे तब हम हिडन मार्कोव मॉडल का उल्लेख करेंगे और देखेंगे कि इससे कैसे परिचित हो सकते हैं। हम इस पर थोड़ा प्रकाश जरूर डालेंगे, लेकिन अन्यथा हम अधूरी जानकारी वाले खेल को नहीं देखेंगे, ठीक है। दो खिलाड़ियों के खेल को कभी भी कई एजेंटों में बदला जा सकता है। केवल मुद्दा सिंक्रोनाइज़ेशन का है जिसके बारे में मैंने बात की थी उसे जोड़ा जा सकता है। और हम यह भी मानते हैं कि दोनों ही प्रतिद्वंद्वियों के लक्ष्य पूरी तरह से एक दूसरे के विपरीत हैं। तो मेरी जीत दूसरे व्यक्ति की हार है और उसकी जीत मेरी हार है, ठीक है। ऐसा नहीं है कि हम दोनों ही जीत सकते हैं, इस तरह की स्थिति की अभी हम बात नहीं करेंगे। तो एक गेम ट्री ही एक सर्च ट्री है लेकिन फिर पारंपरिक सर्च ट्री के विपरीत इसमें परतें अलग हैं। पहली परत अगर मैं पहली चाल खेल रहा हूँ, तो मैं इसे अधिकतम कहता हूँ क्योंकि मैं जीतने के अपने अवसरों को अधिकतम करने जा रहा हूँ। अगला लेवल प्रतिद्वंद्वी द्वारा खेला जाता है और मेरे जीतने की संभावनाओं को कम करता है। फिर से, अगले से अगला लेवल मेरा अपना है जहाँ मैं अपने जीतने की संभावना को अधिकतम कर सकता हूँ। तो इसीलिए इन्हें न्यूनतम-अधिकतम परत कहा जाता है। अधिकतम परत वह परत होती है जहाँ खिलाड़ी खेलता है और न्यूनतम परत वह होती है जहाँ प्रतिद्वंद्वी खेलता है। तो कई परिणाम हो सकते हैं। टिक टैक टो के मामले में तीन संभावित परिणाम हो सकते हैं जीत, हार और ड्रा। टिक टैक टो को स्क्रीन पर दिखाया गया है। जीतने के आठ अलग-अलग तरीके हैं। आप जिसे प्राप्त करना चाहते हैं वह है लगातार तीन सेल और आप उन्हें चिह्नित करते हैं। और अगर आप लगातार तीन सेल चिह्नित हैं तो आप जीत जाते हैं। तो स्क्रीन पर जीतने के आठ अलग-अलग तरीके दिखाए गए हैं और एक और आकृति भी है जो संपूर्ण सर्च ट्री का वर्णन करती है। पूरा न होना या नॉट कंप्लीट भी इसका एक बहुत छोटा सबसेट है और हम इसके हर एक चाइल्ड को नहीं खोज रहे हैं। हम प्रत्येक परत में केवल एक चाइल्ड की खोज कर रहे हैं, जाहिर है स्क्रीन पर जगह की कमी के कारण। लेकिन अगर जगह की कमी नहीं है, तब भी इस मामले में बहुत बड़ी बात है, लेकिन फिर उन स्टेट्स को देखें जिन पर गोले बनाए गए हैं। वन, टू और एक है जिसे W कहा जाता है, एक और को L कहा जाता है। अब इस वन में, आप देख सकते हैं, मेरे पास एक ही लाइन में दो एक्स हैं लेकिन फिर शून्य खेला गया है। और दूसरे में आपके पास एक पंक्ति में दो एक्स हैं जहां शून्य कहीं और खेला गया है। अब इन दोनों में क्या अंतर है? जब दो एक्स एक पंक्ति में होते हैं और जब शून्य को आगे रखते हैं, तो मैं उस व्यक्ति को जीतने से रोकता हूं और जब मैं शून्य को कहीं और खेलता हूं, तो मैं उसे रोक नहीं रहा हूं। मैं अपनी हार को सुनिश्चित कर रहा हूं। तो, यह इस तरह होता है जहां आप देख सकते हैं कि यह उस जानकारी के आधार पर जीतने या हारने का परिणाम है। तो, W जीत रहा है। आप देख सकते हैं कि सभी तीन एक्स एक पंक्ति में हैं तो हम जीतते हैं और जब तीन शून्य एक क्रम में होते हैं तो हम हारते हैं। तो, एक है W, हम एक ऐसे स्टेट तक पहुंचना चाहते हैं जो W है और हम उन स्टेट्स से बचना चाहते हैं जो L हैं यदि हमें W नहीं मिलता है, तो हम D से संतुष्ट हो सकते हैं जो छूट गया है। इस मामले में, आप देख सकते हैं कि यह संभव है और क्योंकि यह इतना छोटा प्रोग्राम है, प्रोब्लम स्पेस , स्टेट खुद ही वास्तव में उन सभी को ड्रॉ कर सकता है। शतरंज के मामले में, मैं इसे ड्रॉ भी नहीं कर सकते। लेकिन आप आसानी से समझ सकते हैं कि यहां तीन संभावित परिणाम हैं-जीत, हार और ड्रॉ। तो, आप देख सकते हैं कि कुछ मामले हैं जहां कोई भी जीतता नहीं है। उनमें से किसी को भी वह चीज क्रम में नहीं मिलती है। तो, यह गिरावट है और दूसरे खिलाड़ी के लिए तीन कम विकल्प हैं जिन्हें आप भी देख सकते हैं। अब इसके साथ ही हम इस मॉड्यूल के अंत में आएंगे। हमने इस मॉड्यूल में क्या देखा है? हमने अभी खेल खेलना की बात शुरू की है। हमने कुछ सिद्धांतों को देखा है और हमने स्वीकार्य चाल जनरेटर को देखा है, हमने स्टैटिक इवैल्यूएशन फंक्शन के बारे में बात की है, हमने खेल खेलने की कलन विधियों के इतिहास को देखा है, हमने एक खोज प्रक्रिया को देखा है जिसमें न्यूनतम और अधिकतम परत की आवश्यकता होती है, अधिकतम परत , खिलाड़ी खेल रहा होता है न्यूनतम परत , प्रतिद्वंद्वी खेल रहा होता है, ये खिलाड़ी के जीतने की संभावना को कम करती है। और इस टिप्पणी के साथ हम इस सत्र को समाप्त करते हैं, लेकिन यह बाद के मॉड्यूल के लिए पूर्वापेक्षा है, जहां हम वास्तव में थोड़ी और गहराई से खेल खेलने के बारे में सीखेंगे। धन्यवाद।
