मित्रांनो, कृबुच्या सोळाव्या विभागात आपले स्वागत आहे. या विशिष्ट मॉड्यूलमध्ये आपण फॉरवर्ड अँड बॅकवर्ड स्टेट स्पेस प्लानिंग पहात आहोत. आधीच्या मॉड्यूलमध्ये प्लानिंग या शब्दाचा काही वेळा उल्लेख केला गेला आहे आणि या विशिष्ट मॉड्यूलमध्ये आपण प्लानिंग म्हणजे काय आणि फॉरवर्ड अँड बॅकवर्ड स्टेट स्पेस प्लानिंग म्हणजे काय किंवा कधी फॉरवर्ड प्लानिंग असे म्हणतात आणि कधी कधी बॅकवर्ड प्लानिंग म्हणतात याबद्दल चर्चा करू. आता, एखाद्या मनोरंजक निरीक्षणाने कदाचित ही गोष्ट आपल्यासमोर प्रकट केली आहे. आपण आतापर्यंत बर्‍याच प्रॉब्लेम्सविषयी बोललो आहे, परंतु नंतर सर्व प्रॉब्लेम्स एकसारखे नसतात. उदाहरणार्थ, जर मी एखादे प्रमेय सिद्ध करणे सुरू केले आणि त्याच्या मध्यावर असताना, मी एका चुकीच्या मार्गावर जात आहे असे मला आढळले तर मी आतापर्यंत जे काही केले आहे ते विसरून पुन्हा सुरुवात करू शकतो. आता जर मी एखादे वर्ड डॉक्युमेंट एडिट करीत आहे आणि काही केले आहे, तर थोड्या वेळाने मला विश्वास आहे की अरे मी जे काही करतो आहे ते बरोबर नाही. मला हे दुसर्‍या मार्गाने करावे लागले, मी पुन्हा सुरुवात करू शकतो? आपण हे करू शकत नाही, मी जे केले ते मला पूर्ववत करावे लागेल परंतु मी पूर्ववत करू शकतो. एकदा मी हे पूर्ववत केले की मी अशा ठिकाणी पोहोचलो जिथे मला थोडा फरक हवा आहे, तर मी पुढे जाऊन ते करू शकेन. मी बुद्धिबळ खेळत आहे. मी दुसर्‍या चालीमध्ये काही चूक केली आहे आणि मी आता पंधराव्या चालीवर आहे. माझ्या लक्षात आले की मी दुसर्‍या चालीमध्ये काही चूक केली आहे, मी परत जाऊन करू शकेन का, मी करू शकतो , मी दुर्लक्ष करतो? मी दुर्लक्ष करू शकत नाही आणि मी परतही जाऊ शकत नाही. तर तेथे तीन वेगवेगळ्या प्रकारचे प्रॉब्लेम्स आहेत. एक प्रॉब्लेम असा आहे की जिथे आपण सर्च स्पेस एक्सप्लोर करत आहात. मध्यावर असताना, आपण कुठे होता हे विसरून जा आणि पुन्हा सुरू करा, अगदी ठीक. दुसर्‍या क्रमांकाच्या केसमध्ये , आपण फक्त ते करत नाही परंतु तरीही आपण परत येऊ शकता. आपण घेतलेल्या स्टेप्स आपण काळजीपूर्वक पूर्ववत करू शकता आणि जिथून आपल्याला असा विश्वास आहे की तिथून त्रुटी आली आहे तिथून प्रारंभ करा. तिसर्‍या क्रमांकाच्या केसमध्ये आपल्याकडे एकही पर्याय नाही. त्या विशिष्ट ठिकाणाहून आपण जे काही करता ते चांगले करावे लागेल. आपण परत जाऊ शकत नाही, आपण पूर्ववत करू शकत नाही. तर, हे तीन प्रकारचे प्रॉब्लेम्स आहेत. बहुतेक केसेसमध्ये , आपण पाहू शकता की प्रॉब्लेम क्रमांक तीन सर्वात कठीण आहे. आता, आपल्यासाठी त्या कठीण प्रॉब्लेमचे थोड्या कमी कठीण प्रॉब्लेममध्ये रूपांतरित करणे शक्य आहे काय? प्रॉब्लेम दोन मध्ये प्रॉब्लेम प्रकार तीन? त्या युक्तीला प्लानिंग म्हणतात. तर, त्यानुसार आपण त्यासंदर्भात योजना आखू शकता की मी ज्या केसबद्दल बोललो आहे, ज्यामध्ये आपण आपल्या प्रवासाची प्लानिंग करीत आहात किंवा आपण खरोखर प्रवास करीत आहात. जेव्हा आपण प्रत्यक्ष प्रवास करत असाल, तेव्हा आपण परत जाऊ शकत नाही आणि पुन्हा सुरु करू शकत नाही, ठीक आहे मी हे आधीच सांगितले आहे. तर वास्तविक प्रवासहा तिसऱ्या प्रकारचा प्रॉब्लेम आहे. आपण प्रत्यक्षात हे करू शकत नाही, कधीकधी ते दुसऱ्या प्रकारात असते, आपण परत जाऊ शकता आणि नंतर पुन्हा घेऊ शकता परंतु तरीही तो अतिरिक्त भार आपल्यास लागेल. म्हणून जर आपण बुद्धीबळाच्या केसमध्ये प्लानिंग करणे सुरू केले तर सर्वात चांगली गोष्ट म्हणजे प्लॅन बनविणे. आपण काय खेळता, प्रतिस्पर्धी काय प्रतिसाद देतो ते पहा आणि आपला प्रतिसाद काय असतो आणि वगैरे वगैरे. त्या आधारे आपण आता आपली चाल निश्चित करू शकता. तर, प्लानिंग आपल्याला या गोष्टी सुधारण्यास मदत करते. तथापि, एआय प्रोग्राम्ससाठी प्लानिंग देखील अत्यंत महत्वाचे आहे. प्रत्येक गोष्टीसाठी प्लानिंग महत्त्वाचे असते. परंतु सोल्यूशन प्लॅन करण्यासाठी प्लानिंग करणे खूप उपयुक्त आहे कारण जेव्हा आपण आधीपासूनच सोल्यूशनचा प्लॅन तयार करता तेव्हा विशेषतः प्रॉब्लेम हे टाइप तीन सारख्या प्रॉब्लेमसाठी हे आपल्याला सर्वोत्तम मार्ग शोधण्यात मदत करेल कारण आपण अशा स्थितीत परत येऊ शकणार नाही आणि नंतरच्या टप्प्यावर एक चांगला मार्ग निवडा. आपण प्लानिंग सुरू करण्यापूर्वी, आपल्याकडे उद्दीष्टांचा एक संच असणे आवश्यक आहे. आता हे खूप महत्वाचे आहे कारण हा प्लॅन आपण निवडलेल्या उद्दीष्टांच्या संचावर आधारित असते. एका शहरातून दुसर्‍या शहरात जाण्याचा मार्ग शोधण्याचे एक अगदी साधे उदाहरण घेऊ. आता जर आपला हेतू कॉस्ट कमी करायची असेल तर ठीक आहे, आपण निवडू शकता, आपण फक्त आवर्तन निवडू शकता, कारण हा सर्वात चांगला पर्याय आहे, परंतु त्या शहरापर्यंत पोहोचण्यास कदाचित दोन तास लागतील परंतु ठीक आहे, कॉस्ट असलेले प्रभावी, उत्तम कॉस्ट असलेले प्रभावी सोल्यूशन आहे. आपण आपला हेतू म्हणून युझरच्या सोयीस प्राधान्य दिल्यास आपण प्रवास करण्यासाठी लक्झरी कारला प्राधान्य देऊ शकता किंवा इतर कोणालाही कॉस्ट तसेच लक्झरी पहायला आवडेल. आपण कदाचित दुचाकी वाहन पसंत कराल. तर, उद्दीष्टांचा एक वेगळा सेट पाहता प्लानिंग बदलणार आहे. इतकेच नाही तर या केसमध्ये एका शहरातून दुसर्‍या शहरात जाण्यासाठी अनेक मार्गदेखील असू शकतात. एक अतिशय छोटा मार्ग आहे, परंतु अतिशय, खूप गर्दीचा. तर, जर तुम्हाला कारने प्रवास करायचा असेल तर तो रस्ता फार चांगला नाही. आपण कदाचित एखादा रस्ता पसंत करू शकता, जो जास्त लांब असेल परंतु कमी रहदारीचा असेल. तर, आपल्या उद्दीष्टांच्या आधारे आपण प्लानिंग करत आहात. तर, हे उद्दीष्ट अतिशय महत्वाचे आहे. तर, उद्दिष्टे काय आहेत? खरं तर, आपल्याला प्लानिंगसाठी आवश्यक असलेल्या दोन गोष्टी. आपल्याला काय करायचे आहे हे आपल्या उद्दीष्टांवर आधारित आहे आणि दुसरे म्हणजे आपण हे कसे करणार आहोत की परिणाम आणि सामान्यत: परिणाम म्हणजे काय तर परिणाम म्हणजे चालीचा क्रम आहे; चाल एक, चाल दोन, चाल तीन, चाल चार आणि जर आपण मागील मॉड्यूल पाहिले तर त्यांना ऍक्शन्स म्हणतात. एजंट ऍक्शन्स करतो, ठीक आहे. मुळात, ऍक्शन ही एखाद्या नियमांची अंमलबजावणी असते आणि त्यातही काही फरक आहे. मला आता या फरकाबद्दल बोलू द्या. जेव्हा मी असे म्हणतो की, बुद्धीबळातील एक प्यादा दोन ओळी आगाऊ दोन ओळींमध्ये चाल केले आहे, एक प्यादा दोन ओळींमध्ये आगाऊ हे जे विधान आहे आणि नियम आहे, ठीक आहे. जेव्हा नियम लागू केला जातो तेव्हा सारणी प्रोग्राम बदलतो. पण वास्तविक हालचाल झालीच पाहिजे. तर एजंट मुळात ते करत आहे आणि तो प्यादा पुढे सरकतो. तर, ऍक्शन प्रत्यक्षात नियम लागू करते. तर ही नियम अंमलबजावणी आहे. वास्तविक जगामध्ये हा नियम कसा लागू केला जातो हे ऍक्शनद्वारे वर्णन केले जाते. म्हणून, जेव्हा आपल्याला एखादी ऍक्शन लागू करायची असेल, तेव्हा अगदी सारखेच असेल, लक्षात ठेवा, नियम आणि ऍक्शन अगदी समान आहेत. ऍक्शन फक्त त्याची अंमलबजावणी आहे. आपण दिलेल्या स्टेटमध्ये एखादा नियम लागू करू इच्छित असल्यास किंवा एखादी ऍक्शन लागू करू इच्छित असल्यास, तेथे दोन गोष्टी आवश्यक आहेत. पहिली गोष्ट म्हणजे पूर्व अटी . जर मला तो तुकडा पुढे चाल करायचा असेल तर, तुम्हाला माहिती आहे की दोनसाठी मला तो प्यादा चाल करायचा असेल तर दोन ओळी पुढे घ्याव्या, दोन्ही ओळींमध्ये दुसरा प्यादा नसावा. तर ही पूर्व अटी आहे. पूर्व अटी न ठेवल्यास, मी हा नियम जनरेट करू शकत नाही. म्हणून, ज्या सेलवर मी चाल करु इच्छितो त्या व्यापलेल्या असल्यास ही क्रिया शक्य नाही. ठीक आहे, जेणेकरून मी करू शकत नाही. म्हणूनच ऍक्शन्स लागू होण्यासाठी आवश्यक असलेल्या गोष्टीशी पूर्व अटी मॅच होणे आवश्यक आहे. खरं तर, इतर महत्वाची गोष्ट. आपल्यासाठी बर्‍याच क्रिया उपलब्ध असू शकतात. अर्थात, पहिली आवश्यकता पूर्व अटी आहे. जेथे ऍक्शन दिलेल्या स्टेटमध्ये लागू केली जाणे आवश्यक आहे. दुसरी गोष्ट म्हणजे ऍक्शन स्वीकार्य असू शकेल, परंतु त्या ऍक्शनमधून एखादे गोल प्राप्त होईल की ते माझ्या स्टेटच्या जवळ असलेल्या गोल स्टेटकडे चाल करेल? जर ते केले तर ते अधिक चांगले आहे. हे अधिक स्वीकार्य आहे. तर ही दुसरी गोष्ट आहे ज्याबद्दल आपल्याला शिकायला आवडते. म्हणूनच कधीकधी आपल्याकडे एकाधिक एजंट्स असतात, तेव्हा आपल्याला अशी ऍक्शन निवडण्याची आवश्यकता असते जी आपल्याला गोल स्टेटच्या अधिक जवळ चाली करते आणि अशा ऍक्शन्स संबंधित रिलेव्हन्ट ऍक्शन्स म्हणून ओळखल्या जातात. आणि जेव्हा जेव्हा ऍक्शन्सचा क्रम असतो तेव्हा A एक, A दोन, A तीन, A चार, A पाच नंतर A एक नंतर एखादा लागू होतो तेव्हा ही पूर्व अटी A दोन जनरेट करते. जेव्हा A दोन लागू केले जाते, तेव्हा A दोन पूर्व अटी A तीन जनरेट करते आणि असेच यापुढेही. ठीक आहे, तर ही इतर गरज आहे आणि एक उदाहरण देखील आहे. उदाहरणार्थ, एखादा एजंट जो इन्ट्रुझन ओळखण्यास सक्षम आहे, अशी एक स्टेट आहे जी असे सांगते की सर्व्हिस अटॅक डिनायल करण्याची शक्यता आहे. आता, आपल्याला या स्टेटमधून चाल करावे लागेल आणि जेव्हा इन्ट्रुझन डिटेक्शन एजंटचे उद्दीष्ट आवश्यक असेल तेव्हा उद्दीष्ट बर्प कन्फर्म करणे. म्हणूनच ते अशा स्टेटमध्ये जाते या गोष्टीस कन्फर्म म्हणतात, ठीक आहे. तर, त्यास चाल करावे लागेल. दुसरे एक अन्य उद्दीष्ट म्हणजे दुसरी स्टेट म्हणजे नेटवर्कमध्ये असलेल्या इतरत्र कार्यरत इतर IDS एजंट्सशी संवाद साधणे आणि तिसरे म्हणजे प्रतिबंधात्मक कारवाई करणे होय. तर या तीन गोष्टी करायच्या आहेत. मग, ते काय करते? ते अटॅक जनरेट करते, हा अटॅक म्हणजे क्रमवार अटॅक आहे जो क्रमाने प्रतिसाद करतो असे मी म्हणेन, अटॅकची तपासणी करतो, अटॅक कन्फर्म करतो आणि नंतर प्रतिबंधात्मक ऍक्शन करतो. आता या तीन ऍक्शन्स घडतील. आता, आपण पाहू शकता की या तीन ऍक्शन्स केवळ या अनुक्रमात घडतील. आपण फक्त प्रतिबंधात्मक ऍक्शन्स घेऊन आणि नंतर काहीतरी करू शकता असे होऊ शकत नाही. आपल्याला त्या अटॅकला आधी कन्फर्म करावे लागेल. तर, ज्याशिवाय आपण कार्य करू शकत नाही. बुद्धिबळात अशी चाल जी दोन प्याद्यांना एकाचवेळी चित् करू शकेल ही शक्यता वापरून हँडआउटमध्येही अशाच केसचे वर्णन केले आहे. एक मजेचा मुद्दा असा आहे की केवळ आपणच प्लानिंग करत नसतो तर अटॅकर्सही प्लानिंग करत असतात. म्हणून जेव्हा आपण काहीतरी करत असतो तेव्हा अटॅकर्सदेखील काहीतरी करत असतात, ठीक आहे. तर, आपल्याला याची अशी खात्री करून घायची आहे कि आपला प्लॅन असा असावा की जर अटॅकर आपला प्लॅन नाकारण्यासाठी एखादा प्लॅन करत असेल तर आपल्याला प्रतिस्पर्ध्याच्या पुढे जाऊन विचार करावा लागेल आणि ते खरोखर एक मनोरंजक काम आहे. तर, प्लानिंग हे नेहमीच सरळ-सोपे नसते. जेव्हा बुद्धीबळासारख्या खेळात एखादा प्रतिस्पर्धी सामील असतो, तेव्हा आपण त्यासंबंधित काही समस्या यापूर्वी पाहिल्या आहेत. ठीक आहे, जेव्हा प्रतिस्पर्ध्याने आपल्या पुढे जाऊन विचार केला तर आपण खेळ गमावणार आहोत, ठीक आहे. तर ते येथे गंभीर आहे. पुढील स्लाइडवर प्रदान केलेल्या उद्दीष्टांची एक नमुना यादी आहे, ज्यामध्ये अटॅकर्सचा किमान प्रवेश मर्यादित करणे, कोणत्याही यंत्रणेतील व्यत्यय वगळणे याविषयी सांगितले गेले आहे आणि वगैरे वगैरे आता, विचार असा आहे की जेव्हा मी प्लानिंग करत असतो तेव्हा हि उद्दीष्टे पूर्ण झाली पाहिजेत. परंतु सर्व बाबतीत नाही, सर्व उद्दिष्टे पूर्ण करणे शक्य आहे, आपल्याला प्रत्यक्षात तडजोड करावी लागेल. कधीकधी काही उद्दिष्टे पूर्ण केली जातात तर काही उद्दिष्टे पूर्ण केली जात नाहीत. दोन पर्याय आहेत एक पर्याय 90 टक्के उद्दीष्टे पूर्ण केली जातात तर दुसऱ्या केसमध्ये 80 टक्के उद्दीष्टे पूर्ण केली जातात, ते शक्य आहे. म्हणून, जेव्हा आपण उद्दिष्टे आणि ऍक्शन्सला जोडण्याचा प्रयत्न करता तेव्हा, आपल्या ऍक्शन्स या उद्दीष्टांसह संरेखित करणे आवश्यक आहे. उदाहरणार्थ, जेव्हा आपल्याला समजते कि हा धूर्त युझरचा आयपी ऍड्रेस आहे, तेव्हा आपल्याला माहित आहे की हे धूर्त युझर आहेत, आपण त्याला ब्लॉक करू शकतो. आता आपण एखादा आयपी ऍड्रेस जाणून घेतल्याशिवाय त्याला ब्लॉक करू शकत नाही. तर, त्या अनुक्रमेचे अनुसरण केले पाहिजे. पूर्व अटी असेल तरच ऍक्शन घेता येईल. ऍक्शन तेव्हाच शक्य आहे जेव्हा ही पूर्व अटी जनरेट करण्यासाठी काही ऍक्शन घेतली जाईल. उदाहरणार्थ, मी अटॅकरचा आयपी ऍड्रेस ब्लॉक करू इच्छितो मला काही ऍक्शन घेणे आवश्यक आहे, ज्यामुळे मला तो आयपी ऍड्रेस मिळेल. तर, त्या ऍक्शन्सची त्या प्रकारे यादी केली जाईल. आता, मला आवडते जेव्हा आपण स्टार्ट स्टेटपासून पोहोचतो तेव्हा आपण सातत्याने खात्री करतो की उद्दिष्टांकडे लक्ष दिले आहे की नाही. मग तेथे दोन प्रकारचे कन्स्ट्रेन्टस आहेत. मी त्यांना सॉफ्ट कन्स्ट्रेन्टस आणि हार्ड कन्स्ट्रेन्टस म्हणतो. आणि या गोष्टी काय आहेत हे समजावून सांगण्यासाठी मी एक साधर्मिती घेतली आणि ती एका शैक्षणिक डोमेनमधून घेतली. एक टाइम टेबल तयार केले जात आहे. आता एक कन्स्ट्रेन्टस असा आहे की शिक्षक एकाच वेळी दोन वर्ग घेऊ शकत नाही. आता, ही एक हार्ड कन्स्ट्रेन्ट आहे. आपण त्याचे उल्लंघन करू शकत नाही, आपण इच्छित असाल तरीही आपण त्याचे उल्लंघन करू शकत नाही. परंतु इतर कन्स्ट्रेन्टस ज्याला सॉफ्ट कन्स्ट्रेन्ट म्हणतात, शिक्षक सलग दोन वर्ग घेऊ शकत नाही. आता, ही चांगली गोष्ट आहे की जर शिक्षकांनी सलग दोन वर्ग घ्यावे लागतील तर वितरण समान पातळीवर होणार नाही. तर, आपण टाळण्याचा प्रयत्न केला पाहिजे परंतु असे नाही की शिक्षक असे करूच शकत नाही. म्हणूनच याला सॉफ्ट कन्स्ट्रेन्ट म्हणतात जे आपण एकदाच उल्लंघन करू शकता. तर, उद्दीष्टे देखील त्या प्रकारची आहेत, ठीक आहे-युझरची सुविधा. उदाहरणार्थ, वापरकर्त्याची सुविधा ही एक उद्देश आहे जी मला पूर्ण करावी लागेल. तर, युझरनी नेटवर्क संथ असल्याचे किंवा सर्व्हर ऍक्सेसेबल नसल्याचे आणि हे सर्व शोधू नये परंतु जेव्हा एखादा गंभीर अटॅक नेटवर्कवर होत असेल तर तो अधिक चांगला असतो, आपण असे म्हणू शकता की युझरची सोय मागे व मागे घेते, आपण फक्त काही पावले उचलता जे त्या अटॅकला नाकारण्यासाठी आपल्याला आवश्यक आहे. युझरला सेवेबद्दल थोडेसे असमाधानी होऊ द्या, अगदी ठीक आहे. तर, उद्दिष्टावर कमी लक्ष्य दिले जात आहे. तर ते तिथेच असावे. तर हा एक अतिरिक्त मुद्दा आहे. आपण काय करायचे आहे ते म्हणजे हार्ड अँड सॉफ्ट कन्स्ट्रेन्टस शोधणे आणि अशा मार्गाचा अनुसरण करणे जे आपल्याला व्यवस्थापित करण्यात मदत करतात किंवा दोन्ही प्रकारच्या कन्स्ट्रेन्टस , ठीक आहे. आणि त्या आधारे आपण आपले कार्यप्रदर्शन काय आहे हे ठरविता. आणि असे बरेच प्रकारचे प्लानिंग्स आहेत- सिम्पल प्लानिंग आणि डिटेल्ड प्लानिंग यात आपण बरेच काही करत नाही. आपण फक्त वर्णन करतो आणि ते जलद होते पण समस्या अशी आहे की तपशील भिन्न असू शकतो आणि कदाचित एखादी समस्या तयार करेल. डिटेल्ड प्लानिंग अधिक चांगले आहे कारण आपण अंमलबजावणी करीत असताना आपल्याला काळजी करण्याची आवश्यकता नाही परंतु त्यानंतर त्यास अधिक वेळ लागेल. ठीक आहे, परंतु नंतर इतर समस्या आहेत. उदाहरणार्थ, जगाचा अंदाज आहे की नाही हे आहे. तर तुम्ही म्हणता की मी हे घेऊन जाईन जेथे जग असे होईल. आणि मग मी आणखी एक पाऊल उचलले जसे कार्ड्स, तुम्ही म्हणता की तुम्ही म्हणता की मी हे कार्ड खेळते आणि मग कारण हे इतरही खेळतील असे मला वाटते, मला आणखी एक कार्ड खेळायचे आहे. आता, ते तुमच्या हातात नाही. जगाचा अंदाज येत नाही. सेल्फ-ड्रायव्हिंग कारच्या केसमध्ये , यापेक्षा अधिक अंदाज किती आहे? आपल्याला माहिती असेल की जेव्हा मी ब्रेक लावतो तेव्हा वाहनाचा वेग कमी होईल, जेव्हा मी एक्सेलरेटर दाबतो, तेव्हा वाहनाचा वेग वाढेल. तर, जग अंदाजे आहे आणि बहुतेक केसेसमध्ये मी माझ्या ऍक्शनचा परिणाम सांगू शकतो. तर, जग नक्कीच आहे परंतु नंतर आपण एट पझल केसमध्ये सोडले तर हे जग अत्यंत अंदाजे आहे. मी ऍक्शन्सचा क्रम प्रदान करू शकतो आणि हे मी उत्तर मिळविण्यास सक्षम आहे की नाही हे स्पष्टपणे सांगेन. ड्रायव्हिंग कार हे सर्व अंदाज लावण्यासारखे नसते आणि त्या तुलनेत कार्ड खेळणे जवळजवळ एक अनिश्चित आहे. तिसरा, किंवा पुढचे उदाहरण, जग बदलत आहे, हे विचारात घेत असताना आता आपल्याकडे एक परिस्थिती आहे आणि तुम्ही पुढचे पाऊल टाकण्याचा विचार करत आहात तोच हे जग बदलेल की नाही. बुद्धीबळाच्या केसमध्ये आपल्याकडे बुद्धिबळ पट आहे. प्रतिस्पर्ध्याने आपली चाल खेळली आहे आता आपल्याला आपली स्वतःची चाल खेळावी लागेल. परंतु त्यापूर्वी, आपण थोड्या वेळासाठी विचार करू शकता, दोन मिनिटे, पाच मिनिटे, दहा मिनिटे. जग बदलणार नाही. जग तसेच राहणार आहे. सेल्फ-ड्रायव्हिंग कारच्या विपरीत, कदाचित जग बदलू शकेल आणि ते प्रत्यक्षात बदलत असेल. जर सेल्फ-ड्रायव्हिंग कारला निर्णय घेण्यास पाच सेकंद लागल्यास ती उजवीकडे वळण घेऊ इच्छित आहे ती सर्व काही पहाते आणि उजवे इंडिकेटर सुरू करते, तर ती उजव्या आरश्यावर दिसते आणि सर्व काही आणि ती त्यावर कार्य करीत आहे आणि त्यात पाच सेकंद निघून गेले आहेत आणि ती काय प्रत्यक्षात ते करावे तसे हे पुन्हा करू शकते . जसे कि दिशा बदलण्यापूर्वी तिने उजवीकडे आरशात पाहावे. का? कारण जग बदलत आहे आणि शेवटच्या पाच सेकंदात काही इतर वाहने दृश्यात येण्याची आणि अशा प्रकारे येण्याची शक्यता आहे की आता जर उजव्या बाजूला वळण घेतले तर एखाद्या अपघाताला सामोरे जावे लागेल. तर, जग बदलत आहे. तर ती इतर समस्या आहे. चौथे आहे की जग पूर्णपणे दृश्यमान आहे की नाही. कधीकधी जग खूपच छान दृश्यमान आहे. बुद्धीबळाच्या केसमध्ये जग पूर्णपणे दृश्यमान आहे. सेल्फ-ड्रायव्हिंग कार हवामानाशी संबंधित कोणताही प्रश्न नसल्यास, ती पुन्हा बऱ्यापैकी दृश्यमान आहे. कारच्या केसमध्ये , जग दृश्यमान नाही. इतरांकडे असलेल्या कार आपल्याला ठाऊक नसतात. आपण फक्त गृहित धरू शकता, आपण फक्त अंदाज लावू शकता आणि कार्य करू शकता, ठीक आहे. फक्त अंदाज लावा आणि काम करा. तर, त्या प्रत्येकासाठी आपल्याला वेगवेगळ्या प्रकारचे प्लानिंग आवश्यक आहे आणि आपण ते का वापरत आहोत? मी पुन्हा आपल्याला सांगतो की आपण एजंट आधारित समस्या, शोधबद्दल का बोलत आहोत. एजंट आधारित शोध आपण पाहिलेल्या इतर शोधांसारखाच आहे, परंतु तो अधिक स्पष्ट आणि तपशीलवार आहे. का? कारण जेव्हा मी असे म्हणतो की त्या गोष्टीवर आधारित मी आलेखात उजवीकडे वळण घेतो तेव्हा मी उजवीकडे वळण म्हटले आणि केले. पण उजवीकडचे वळण काय आहे? एजंट आधारित केसमध्ये असे म्हणतात की उजवीकडचे वळण येथे एक ऍक्शन आहे, असे काहीतरी आहे जे उजवीकडे वळण घेण्याकरिता करावे लागेल, ठीक आहे. तर, ती तपशीलवार प्रक्रिया निर्दिष्ट केली आहे. इतकेच नाही तर अशीही काही अंमलबजावणी होते जी लागू करते. ठीक आहे, उदाहरणार्थ, असे असे म्हटले आहे की स्टीयरिंग व्हील हे एका सामान्य घड्याळाच्या दिशेने चाल केले जाईल. तर ती अल्गोरिदम , ती प्रोसेस देखील प्रदान केली गेली आहे. तर, त्यात मुळात एक प्रोग्राम असतो जो त्या ऍक्शनची अंमलबजावणी करतो, तो नियम लागू करतो, ठीक आहे, जो मी तुम्हाला आधीच सांगितले आहे की ऍक्शन नियम लागू करते. तर इथे त्याचे उदाहरण आहे. ज्यात आपण अधिक स्पष्ट होऊ. आणि ते प्लानिंग जेव्हा आपण प्लॅन करतो तेव्हा दोन वेगवेगळ्या मार्गांनी प्लॅन केले जाते, एक म्हणजे माझ्या आधीच्या अनुभवाच्या आधारे प्लानिंगचा वापर करणे. उदाहरणार्थ, मला कॉन्फरन्स प्लॅन करायची आहे आणि माझ्याकडे आधीपासूनच वीस ते तीस कॉन्फरन्स प्लॅन केल्या आहेत आणि गेल्या काही वर्षांमध्ये मी जे शिकलो त्याचा उपयोग पुढील कॉन्फरन्स प्लॅन करण्यासाठी करू शकतो जी कॉन्फरन्स मी आता आयोजित करणार आहे. पुढच्या वेळी जेव्हा आंतरराष्ट्रीय परिषद आयोजित करायची असेल तेव्हा हे शक्य आहे, हे मी कधीच केले नाही. परंतु नंतर माझा स्वतःचा अनुभव, राष्ट्रीय परिषद आयोजित करण्याचा आंशिक अनुभव मला मदत करू शकेल. मला कदाचित अशी एखादी नोकरी दिली जाईल जी मी यापूर्वी कधीही केली नव्हती आणि मला एक नवीन रूप द्यावे लागेल आणि हे सर्व पुन्हा करावे लागेल. ठीक आहे, म्हणून या दोन भिन्न केसेस आहेत. पहिल्यास केस बेस्ड रीज़निंग म्हणतात. आपल्याला जेव्हा एखादा प्रॉब्लेम येतो तेव्हा एजंटकडे प्रॉब्लेम उद्भवतो, ठीक आहे. ते केस बेस्ड रीज़निंग दुसरे एक आहे. केस बेस्ड रीज़निंग हा तर्क वितर्क करण्यासाठी एक सोपा मार्ग आहे. जेव्हा जेव्हा आपल्याला एखादा प्रॉब्लेम येतो तेव्हा आपण फक्त आपल्या डेटाबेसमध्ये पाहता. तत्सम दिसत असलेला प्रॉब्लेम असल्यास, आपण याआधी घेतलेला सोल्यूशन शोधा आणि ते लागू करा. उदाहरणार्थ, मी एक इनट्रूसन डिटेक्शन एजेंट आहे. जेव्हा मी नवीन अटॅक करतो तेव्हा मी काय करेन, या अटॅकची मी पूर्वी पाहिलेल्या अटॅकशी तुलना करण्याचा प्रयत्न करतो. मलाही असाच अटॅक आढळल्यास, मी या प्रॉब्लेमचे निराकरण करण्यासाठी मी काय केले ते शोधून काढू, ठीक आहे, आणि मग मी त्या प्रोसेसचे अनुसरण करू. ठीक आहे, परंतु नंतर नवीन केस असल्यास, मला एक वेगळा दृष्टिकोन पाळावा लागेल, सहसा असे काहीतरी जे मी आधीपासूनच करत आहे. मी ह्यूरिस्टिक लागू करतो, मी सर्च स्पेस जनरेट करतो आणि मी सर्च स्पेस ओलांडतो. आशा आहे की, मी एका गोल स्टेटमध्ये पोहोचू शकेल, ठीक आहे. केस बेस्ड प्लानिंग कधीकधी मेमरी-बेस्ड प्लानिंग म्हणून ओळखले जाते कारण यात काम पूर्ण होते. आता आपण ज्या पुढील गोष्टीकडे पाहणार आहोत त्याला फॉरवर्ड प्लॅनिंग किंवा फॉरवर्ड स्टेट स्पेस प्लॅनिंग असे म्हणतात. आता, आपण काय करीत आहात, तर आपण परसेप्ट सीक्वेंस जनरेट करता जो अंतिम स्थितीपर्यंत घेऊन जातो किंवा अंतिम स्थितीपर्यंत घेऊन जाण्यासाठी ऍक्शन्स किंवा ऍक्शन्सचा क्रम तयार करता. मूलभूतपणे, कोणत्याही प्लानिंगचे आउटपुट म्हणजे ऍक्शनचा क्रम असतो, फॉरवर्ड किंवा बॅकवर्ड. फॉरवर्ड रीजनिंग , आपण ऍक्शन नंबर एक, दोन, तीन, चार, पाचपासून सुरुवात करा अशा प्रकारे आपण प्रारंभिक अवस्थेपासून सुरुवात करा आणि गोल स्टेटमध्ये पोहोचा. बॅकवर्ड रीजनिंगमध्ये , आपण ऍक्शनपासून n, n वजा एक आणि इत्यादीपासून प्रारंभ करता आणि आपण अंतिम अवस्थेमधून सुरू करण्यापूर्वी सुरुवातीपासून राज्य सुरू होण्यापर्यंत सुरू करता. असो, हे ठीक आहे. पण मग ऍक्शन्स , ऍक्शनचा क्रम काय असेल? एका केसमध्ये , दोन्ही ऍक्शन्स , ऍक्शन A वन दिसणे आवश्यक आहे, ऍक्शन A टूपूर्वी अंमलात आणणे आवश्यक आहे. मग त्याला स्ट्रीक्ट ऑर्डरिंग म्हणतात. उदाहरणार्थ, क्लच दाबून आणि गीअर बदलणे. आता, A वनला A टूच्या आधी घडणे आवश्यक आहे. ठीक आहे, आपण असे न केल्यास, ते होणार नाही. तर ते स्ट्रीक्ट ऑर्डरिंग आहे. परंतु एसी सुरू करणे आणि एक्सेलेरेटर मूल्य वाढवणे या दोन समांतर गोष्टी आहेत. ते एकमेकांशी संबंधित नाहीत, मी त्यांना कोणत्याही प्रकारे ऑर्डर करू शकतो. तर येथे कोणतीच ऑर्डर नाही शिवाय कुठल्या ऑर्डरचा प्रकार, ठीक आहे. पण नंतर एक पार्शियल ऑर्डरिंग आहे. उदाहरणार्थ, मी एसी सुरू करू किंवा गीअर बदलू शकतो परंतु ते फक्त कार सुरू केल्यावरच होते, त्याशिवाय मी हे करूच शकत नाही. त्यास पार्शियल ऑर्डरिंग म्हणतात. मी येथे हेतुपूर्वक निवडलेले आणि पीपीटी वर दर्शविलेले एक उदाहरण आहे, जेथे बॅकवर्ड रीज़निंग चांगले आहे किंवा बॅकवर्ड स्टेट स्पेस प्लानिंग चांगले आहे असे एक केस सूचित करते. आता आपण ती प्रारंभिक अवस्था पाहू शकता आणि अशा अनेक स्टेटस् आहेत ज्या आपण प्रारंभिक अवस्थेतुन जनरेट करू शकता. परंतु अंतिम स्थितीपासून आपण फक्त त्याकडे पाहता, आपल्या लक्षात येईल की एखाद्याने त्या अंतिम स्थितीमध्ये प्रारंभिक अवस्थेच्या चार वेगवेगळ्या घटकांमध्ये रुपांतरित करणे खूपच वेगवान आहे. कारण प्रॉब्लेम असा आहे की मी त्या प्रकारे डिझाइन केले आहे. बॅकवर्ड रीज़निंगची उपयुक्तता दर्शविण्यासाठी मी हे उदाहरण दिले आहे. या केसमध्ये , बॅकवर्ड रीज़निंग जोरदार उपयुक्त आहे. तर, काही संभाव्य चाली येथे दर्शविल्या गेल्या आहेत. म्हणून, जर आपण प्रारंभिक अवस्थेसह सुरु केले, तर आपण काय करू शकता, तर आपण दोन गोष्टी करू शकता. एका शीर्षस्थानावरून एक ब्लॉक उचलला आणि तो टेबलवर ठेवला, किंवा आपण त्यास इतर कोणत्याही स्टॅकवर ठेवू शकता. सुरुवातीला पाच स्टॅक आहेत. तर, तेथे बरेच पर्याय उपलब्ध आहेत. पहिल्या ओळीमध्ये , G ला टेबलवर ठेवण्याविषयी सांगितले आहे, नंतर टेबलवर D, आणि नंतर Cला टेबलवर ठेवण्याविषयी सांगितले आहे. तर, सर्वात वर असलेल्या वस्तू आपण टॅबलेवर ठेवत आहे. तर, ते एक आहे. दुसरा, Gला उचलून Cच्या वर ठेवला. पुढचा एक D, Dला उचलून कुठेतरी वर ठेवला. ठीक आहे, पुढील Cला उचलून आणि त्यास कुठेतरी वर ठेवले. तर, बरेच पर्याय उपलब्ध असल्याचे आपण पाहू शकता. आपण बॅकवर्ड चाल केल्यास, हे होणार नाही. चाल बॅकवर्ड केल्याने, केवळ एकच स्टेट संभाव्य आहे ती म्हणजे Aला परत टेबलावर ठेवणे. आणि हा एकमेव संभाव्य पर्याय आहे आणि म्हणूनच हे चांगले कारण आहे की आपल्याकडे फक्त एकच पर्याय आहे, ठीक आहे. जेव्हा एक पर्याय असतो तेव्हा आपल्याला निवडण्याची आवश्यकता नसते आणि ते जलद होते. आणि त्यास कधीकधी ब्रांचिंग फैक्टर म्हटले जाते. अग्रेषित दिशेने ब्रांचिंग फैक्टर खूप जास्त आहे. मागील दिशेस ब्रांचिंग फैक्टर खूप लहान आहे. कधीकधी बॅकवर्ड प्लानिंग हे गोल डायरेक्टेड रीज़निंग म्हणून देखील ओळखले जाते. परंतु नंतर आपण कदाचित काही पावले उचलू शकता. ती योग्य दिशेने आहे की नाही हे देखील पाहणे आपल्यासाठी खूप महत्वाचे आहे. मी म्हणालो की मी संबंधित शब्द वापरतो. तर, कधीकधी, आपण केलेली चाल संबंधित आहे की नाही हे देखील पहावे लागेल. आणि हे हयूरिस्टिक नाही. कृपया हे समजून घ्या, मी आत्ता हयूरिस्टिकविषयी बोलत नाही आहे. असे समजा की स्टार्ट स्टेटमध्ये काही घटक आहेत. या गोल स्टेटमध्ये काही घटक आहेत. आता जेव्हा आपण चाल करता तेव्हा असे काही घटक असतात जे स्टार्ट स्टेटमध्ये असतात, परंतु गोल स्टेटमध्ये नसतात. गोल स्टेटमध्ये काही घटक आहेत, जे स्टार्ट स्टेटमध्ये नाहीत. समजा, जेव्हा आपण एखादी ऍक्शन लागू केली समजा, त्यात जर स्टार्ट स्टेटमध्ये नसलेला आणि गोल स्टेटमध्ये असलेला एखादा घटक जोडला, तर ते चांगले आहे. हे असा घटक हटवते जो स्टार्ट स्टेटमध्ये आहे आणि अंतिम स्थितीमध्ये नाही, हे देखील चांगले आहे. आता या दोन महत्वाच्या गोष्टी सूचित करतात की ही ऍक्शन करंट स्टेटला एका स्टेटमध्ये परिवर्तित करेल जे प्रारंभिक अवस्थेपेक्षा गोल स्टेटच्या जवळ आहे आणि त्यास प्रारंभिक अवस्थेपासून गोल स्टेटमध्ये चाली करेल. आता ते येथे महत्वाचे आहे. परंतु, बर्‍याच वेळा म्हणजे स्टेटची एक गोष्ट आणि प्रासंगिकता सांगण्याची मला इच्छा आहे. दुसरा एक म्हणजे उप-घटकांच्या आंतर अवलंबित्वाबद्दल प्लानिंग माहिती नसते. मग मी ज्याबद्दल चर्चा केली आहे ते फार महत्वाचे नाही, उपयुक्त नाही. एक मनोरंजक उदाहरण चित्रामध्ये दर्शविले गेले आहे. B टेबलावर आहे, A टेबलवर आहे, C हा D च्या वर आहे, D टेबलवर आहे. आता आपल्याला काय पाहिजे आहे,A हा B वर आहे, B हा C वर विश्रांती घेत आहे आणि नंतर D हा टेबलवर विश्रांती घेत आहे. आता मी जे प्राप्त करू इच्छित आहे ते, टेबल C वर, टेबल D वर, BA वर, AB वर आहे. मला हे यापासून पाहिजे आहे. यामधून, मी म्हणतो की AB माझा पहिला घटक आहे, ठीक आहे. जर मी हे वापरून ते मिळवण्याचा प्रयत्न केला तर प्रॉब्लेम आहे आणि आपण पाहू शकता की जर मी Aला Bच्या वर ठेवले तर ते गोल स्टेटच्या अगदी जवळ आहे परंतु ती गोल स्टेट नाही. खरं तर ते मला ते पुन्हा तोडावे लागेल. आता हे आपण लोकल ह्यूरिस्टिक फंक्शन आणि ग्लोबल ह्यूरिस्टिक फंक्शन याबद्दल चर्चा करताना आपण पाहिले त्यात अगदी साम्य आहे. तथापि, मी गोल स्टेटकडे जात आहे, हे करण्याचा हा योग्य मार्ग नाही. तर ही एकमेकांना जोडणारी गोल्स आहेत. तर, मी कशाबद्दल बोलत आहे, प्रासंगिकता आणि घटक आणि त्या सर्व गोष्टी, गोल्स आंतर-निर्भर नसल्यास केवळ या महत्त्वाच्या किंवा उपयुक्त आहेत. सब गोल्स हे परस्परावलंबित नाहीत. जर ते परस्परावलंबित असतील तर मी AB चे निराकरण करू शकेन ज्यामुळे स्टार्ट स्टेट गोल स्टेटच्या अधिक जवळ येईल. ठीक आहे, जर मी ते केले तर मी गोल स्टेटपर्यंत पोहोचणार नाही, ठीक आहे. पुढील महत्वाची गोष्ट म्हणजे, दिलेल्या केसपैकी , मी कोणती वापरावी? मी फॉरवर्ड रीजनिंग किंवा बॅकवर्ड रीजनिंग वापरायला पाहिजे? असे म्हणण्याचे बरेच मार्ग आहेत की आपण आधीच ब्रांचिंग फॅक्टरबद्दल बोललो आहे. स्टार्ट स्टेटपासून एंड स्टेटपर्यंतच्या ब्रांचिंग फॅक्टर अधिक आहे तर आपण गोल स्टेटपासून प्रयत्न करू नये. पण त्यानंतर इतरही पर्याय आहेत. उदाहरणार्थ, याचा न्याय करण्यासाठी इतर पर्यायी मार्ग. उदाहरणार्थ, जर मी तुम्हाला एखाद्या अज्ञात ठिकाणी जाण्यास सांगितले तर, ज्याला आपण ओळखत असलेल्या ठिकाणाहून, जसे की आपले घर किंवा आपण त्या अज्ञात ठिकाणापासून सुरु करू शकता. आपल्यापैकी बहुतेकजण त्या अज्ञात ठिकाणापासून सुरु करण्यास प्राधान्य देतील, कारण त्या अज्ञात ठिकाणापासून आपण कोणत्याही दिशेने प्रवास केला तर आपण आपल्यास ज्ञात असलेल्या ठिकाणी पोहोचता . आपण ते आपल्या घराशी नेहमीच कनेक्ट करू शकता. म्हणून आपण नेहमी परत येऊ शकता. याचा अर्थ काय? आपण आपल्या होम स्टेटपासून सुरु केल्यास आणि पूर्ण करू इच्छित असल्यास, आपल्याला त्या ठिकाणी रहावे लागेल जेथे आपल्याला जायचे आहे. कारण, अज्ञात ठिकाणी आपल्याला हे माहित नाही की आपण कोठून तेथे पोहोचलात. तर, तेथे पोहोचल्याशिवाय आपल्याला समजणार नाही की आपण गोल स्टेटमध्ये पोहोचलात की नाही. त्याउलट, जेव्हा आपण एखाद्या अज्ञात जागेपासून प्रारंभ करता तेव्हा पर्यायांची संख्या बरेच असते आणि ते सर्व आपल्यासाठी स्टार्ट स्टेट असतात. उदाहरणार्थ, जर आपण गोल स्टेटपासून प्रारंभ केले आणि आपण असे म्हणूया की आपण तेथून दहा, पंधरा, वीस ठिकाणी पोहोचलात, जिथे आपण आपल्या घरापर्यंत पोहोचू शकता तेथे बरेच पर्याय उपलब्ध आहेत. ते पंधरा पर्याय शक्य आहेत. तर, आपण त्यापैकी कोणापर्यंतही पोहोचू शकता आणि आपण तेथे पोहोचाल. म्हणून, जेव्हा असा पर्याय आणि अधिक संख्येने पर्याय उपलब्ध असतात तेव्हा ते अधिक चांगले. दुसरा प्रश्न म्हणजे कोणत्या प्रकारच्या प्रॉब्लेमचे सोल्यूशन काढले जात आहे? उदाहरणार्थ, आपण एका मोठ्या डेटाकडे पहात असल्यास, समोर येत असलेल्या चौकशीच्या पोस्टचे प्रमाण पहा आणि माझे उत्पादन विकले जात आहे की नाही हे मला कळवा आणि जे काही आहे. तर क्वेरी आणि बॅकवर्ड प्रोसेस काय आहे हे समजून घेण्याचे काम मी प्रत्यक्षात करतो आहे. कारण मी क्वेरीपासून सुरुवात करतो. मला एक क्वेरी प्राप्त झाली. मला परत प्रोसेस करावी लागेल. मी सुरुवातीस प्रारंभ करत नाही. मला खरोखर माहित नाही. किंवा जर माझ्याकडे बुद्धिबळसारखा एखादा गेम खेळण्याचा प्रोग्राम असेल तर आता मी अंतिम स्थितीपासून प्रारंभ करू शकत नाही. अंतिम स्थिती काय आहे हे मला माहित नाही. मला जाणून घेण्याचा कोणताही मार्ग नाही, आणि फक्त एका पारंपारिक बुद्धीबळ प्रोग्रामसाठीच नाही, परंतु रोजच्या वर्तमानपत्रांत येणारे बहुतेक कोडे, काही बुद्धीबळ कोडी आपण पाहिले असतील. जरी त्या केसेसमध्ये , एक स्टार्ट स्टेट आहे, परंतु तेथे एकाधिक संभाव्य एंड स्टेटस आहेत. म्हणून, नेहमीच प्रारंभिक अवस्थेपासून किंवा जी काही स्टेट आपल्याला दिली जात आहे त्यापासून प्रारंभ करणे चांगले. तर मुद्दा असा आहे की, या केसमध्ये, फॉरवर्ड रीजनिंग करणे चांगले आहे. दुसरे एक, जर स्पष्टीकरण सुविधा आवश्यक असल्यास, जर एजंटने तर्क समजावून सांगावयाची आवश्यकता भासते. उदाहरणार्थ, आपण स्वयंचलित टॅक्सी घेतल्यास आणि ते असे म्हणतात की पाचशे रुपये, तर आपण विचारू शकता पाचशे रुपये का. त्यास परत जाऊन पाचशे रुपये का आहे हे समजावून सांगावे लागेल. जेव्हा कोणी असे म्हणते की साधारणपणे मी फक्त चारशे देतो आणि आपण पाचशेला विचारत आहात, असे का आहे? त्यासाठी परत प्रोसेस केली पाहिजे आणि त्यासाठीचे तर्क शोधणे आवश्यक आहे. म्हणून जेव्हा स्पष्टीकरण सुविधेची आवश्यकता असते तेव्हा एजंटला गोलपासून प्लानिंग प्रोसेसकडे पहावे लागते. ठीक आहे, तर गोल डायरेक्टेड रीज़निंग किंवा बॅकवर्ड रीजनिंग या केसमध्ये खूप महत्वाचे आहे. इतर केसेसमध्ये , सोल्यूशन कसे लागू केले जाईल? उदाहरणार्थ, मी सोल्यूशन लागू करण्यासाठी प्रोलॉगचा वापर करत आहे. प्रोलॉग हे डिफॉल्टनुसार एक बॅकवर्ड चेनिंग मेकॅनीझम आहे. तर, सहसा आपण आपले गोल प्रदान करता, जेव्हा जेव्हा आपण धावता तेव्हा आपले गोल प्रदान करा आणि त्यातून सोल्यूशन निघेल. ठीक आहे, ते नेहमी बॅकवर्ड दिशेने प्रवास करते. म्हणून, जर आपण प्रोलॉगसारखी भाषा वापरत असल्यास, सर्वात चांगला पर्याय परत चाल करणे हा आहे. आपण पारंपारिक भाषा वापरत असल्यास, जर आपण जावा , सी ++, पायथन आणि त्यासारख्या वापरत असल्यास, सुरवातीपासून प्रारंभ करण्याचा सर्वोत्तम मार्ग आहे. याचा अर्थ असा होत नाही की आपण बॅकवर्डपासून प्रारंभ करु शकत नाही परंतु अशा प्रोग्रामिंग लँग्वेजचा नैसर्गिक प्रवाह फॉरवर्ड दिशेने आहे. तर, आपण असेच केल्यास ते अधिक चांगले आहे. ठीक आहे, तर तो मुद्दा आहे. त्यासह आपण फॉरवर्ड रीजनिंग विरुद्ध बॅकवर्ड रीजनिंग , या चर्चेचा शेवट करू जे आपण शेवटी पाहिले आहे. आपण चर्चा केलेल्या अशा बर्‍याच गोष्टी आहेत. आपण प्लानिंग प्रोसेसकडे पाहिले, आपण प्लानिंगच्या घटकांकडे पाहिले, चांगले प्लानिंग काय आहे याकडे आपण पाहिले, एजंट बेस्ड प्लानिंग , प्रॉब्लेम्स, जग, पर्यावरणासंदर्भातील समस्या आणि वगैरे वगैरे गोष्टींकडे पाहिले. आणि शेवटी आपण फॉरवर्ड अँड बॅकवर्ड रीजनिंग प्रोसेसचे फायदे आणि तोटे यांची तुलना केली आहे. हे सर्व पाहता, आपण आता प्लानिंग प्रोसेसबद्दल बोलण्यास तयार आहोत जे खऱ्या अर्थाने प्रोग्राम्समध्ये होते. ठीक आहे, म्हणून आपण पुढील मॉड्यूलमध्ये त्याबद्दल बोलणार आहोत. त्यासह आपण निष्कर्ष काढू. धन्यवाद!
मित्रांनो आपले स्वागत आहे! आपण आता कृबुच्या एकोणिसाव्या मॉड्यूलमध्ये आहोत. आता आम्ही गेम प्लेईंग ॲल्गोरिदमबद्दल बोलत आहोत. गेम प्लेइंग हे संशोधनातील एक सर्वात जास्त मागणी असणारे क्षेत्र आहे. आणि हे कमाईच्या उत्पन्नाच्या बाबतीतही अतिशय आकर्षक आहे. म्हणून बरेच लोक या दिशेने काम करीत आहेत. खेळ खेळणे हे स्वतःतच कृबु कार्यक्षेत्र आहे आणि आपण खेळ खेळणे हे कृबु कार्यक्षेत्र का आहे, आणि ह्यातील प्रोब्लम्स कोणते आहेत आणि काय सोल्यूशन्स आहे याबद्दल बोलणार आहोत. हे मॉड्यूल आणि त्यानंतरच्या काही मॉड्यूल्समध्ये आपण प्रॉब्लेम आणि सॉल्यूशन्सचा विचार करु. ठीक आहे, आपण गेम प्लेईंग ॲल्गोरिदमची प्रस्तावना आणि त्याचा इतिहास आणि काही अन्य पूर्वापेक्षांनी सुरू करू जे कोणताही खेळ खेळण्यापूर्वी सुरू करायला पाहीजे. व्यावसायिक क्षेत्रात बरेच यश आणि संशोधन आहे. हे खूप मनोरंजक आहे . हे एक अतिशय स्ट्रक्चर्ड डोमेनदेखील आहे. याचा अर्थ काय? स्ट्रक्चर्ड डोमेन , कारण आपण स्टार्ट स्टेट जाणतो. प्रत्येक खेळात, आपण स्टार्ट स्टेटबाबत अतिशय स्पष्ट आहोत. आपण एंड स्टेटबद्दलही अतिशय स्पष्ट आहोत. आपण बुद्धीबळाचे उदाहरण आधीच पाहिले आहे. इतकेच नव्हे तर नियम अतिशय संरचित आहेत, कारण लोक खेळतात, जिंकतात आणि हारतातही, बहुतेक प्रकरणांमध्ये नियमांना खूप चांगल्यारीतीने परिभाषित केले आहे. कोणताही गेम निवडा आणि तुम्हाला त्या नियमांबद्दल स्पष्ट कल्पना मिळेल. तर हे तिसरे वैशिष्ट्य आहे जे आपल्यासाठी अतिशय महत्वाचे आहे. परंतु शेवटी ते मानवांशी संवाद साधतात. एक चेस प्लेईंग प्रोग्राम मानवांशी संवाद साधतो, कार्ड प्लेईंग प्रोग्राम मानवांशी संवाद साधतो आणि आपल्याला हवे आहे की त्या प्रोग्रामने माणसासारखे वागायला हवे आणि तिथेच कृबुचे काम सुरू होते. ठीक आहे, सहसा आपल्‍याला दोन प्रॉब्लेम्स आढळतात ज्यात अशाप्रकारच्या प्रोग्राम्सशी संबंधित दोन गोष्टी असतात. त्यातील एकाला स्वीकार्य मार्ग जनरेटर म्हणतात. बुद्धीबळाचे उदाहरण घ्या. जेव्हा आपण चेसबोर्डकडे पहात असतो तेव्हा शेकडो चाली शक्य असतील. पण तुम्ही शंभर चालींचा विचार कराल का? आपण केवळ पाच, सहा, सात जास्तीत जास्त दहा चालींचा विचार कराल, अधिक नाही. आपण त्याच निवडक चालींना कसे सूचीबद्ध केले आहे? आपल्याला खरे तर माहित नाही. परंतु आपण असे काहीतरी करत असतो कालांतरात आपण हेच करत असतो. खरं तर, ही एक स्ट्रक्चर्ड प्रोसेस आहे. हे न्यूरॉन्ससारखे नाही. येथे एक स्ट्रक्चर्ड प्रोसेस आहे. जेव्हा आपण बुद्धीबळ खेळणे शिकण्यास प्रारंभ करता, तेव्हा कदाचित आपण प्रत्येक नियम लक्षात ठेवू इच्छितो जसे की वजीर अमूक मार्गाने चालतो, तर हत्तीला अशा मार्गाने जायला हवे, वगैरे वगैरे. तर ते आपोआप होत नाही परंतु ठराविक कालावधीत आपण खेळण्याचे नियम शिकतो आणि नंतर आपले स्वतःचे नियम, आपले ह्यूरिस्टिक नियम निर्माण करतो. तुम्ही बुद्धिबळ खेळण्यात पटाईत होता. म्हणून नेहमीप्रमाणे यात पुष्कळशा ह्यूरिस्टिक गोष्टींचा समावेश असतो उदाहरणार्थ, जर असा एखादा खेळाडू असेल जो दोन मोहरा एकाचवेळी चित करणारी चाल खेळण्यात खूप तरबेज असेल, तर प्रत्येक वेळी जेव्हा आपण त्याच्याबरोबर बुद्धीबळ खेळतो तेव्हा आपल्याला ह्याबाबत माहीत हवे. आपण नंतर दोन मोहरांना एकाच वेळी बाद करणार्या चालीबद्दल शिकू. नंतरच्या मॉड्यूलमध्ये आपण त्याबद्दल देखील चर्चा करू. मुद्दा हा आहे की आम्ही ते नियम जनरेट करतो. ते नियम डोमेन ज्ञानावर आधारित आहेत. म्हणूनच डोमेन ज्ञानावर आधारित, आपल्याला माहित आहे की शंभर नियमांपैकी केवळ दहा नियम, दहा चाली महत्वाच्या आहेत आणि आपण केवळ त्यावर लक्ष केंद्रित करतो, आपण फक्त त्या नियमांची तुलना करतो आणि त्यातील सर्वोत्तम निवडतो. तर ही पहिली गोष्ट आपण करू. दुसरी गोष्ट म्हणजे एकदा आपण ती लागू केली की आपण ती गोष्ट करतो आणि शेवटी आपल्याला एंड स्टेटचे काही पर्याय मिळतात, तेंव्हा आपल्याला त्या एंड स्टेटची तुलना करणे देखील आवडेल आणि हे शोधून काढू की कोणते एंड स्टेट आपल्यासाठी चांगले आहे, आणि आपण असा मार्ग निवडायला पाहिजे जो आपल्याला त्या स्टेटमध्ये घेऊन जातो. ठीक आहे, पुन्हा एकदा, एक ह्यूरिस्टिक फंक्शन आहे, ज्याला स्थिर मूल्यांकन फंक्शन असे म्हणतात, जे त्या स्टेट्सना लागू करायचे आहेत आणि स्टेट्सचे स्थिर मूल्यांकन फंक्शनचे मूल्य पाहता आपण हे ठरवू शकू की स्टेट चांगली आहे की नाही? ती स्टेट किती चांगले आहे, मी या चालीने पुढे जावे की नाही, ज्याचा परिणाम ही स्टेट आहे, आणि असेच सर्व. या दोन गोष्टी अशा आहेत ज्या खेळ खेळण्यासाठी अतिशय महत्त्वाच्या आहेत परंतु त्या दोन्ही ही डोमेन ज्ञानावर आधारित आहेत. ते विशिष्ट खेळासाठी विशिष्ट आहेत, बुद्धिबळासाठी इतर कोणत्याही खेळापेक्षा ते वेगळे आहे. ठीक आहे, परंतु नंतर काही गोष्टी अशा आहेत ज्या आपण सामान्यीकृत करू शकतो. उदाहरणार्थ आपण स्टेट स्पेसमध्ये कसे फिरता. मी हे मी पाहिलेल्या त्या उदाहरणांसारखे नाही, तेथे काही फरक आहे जो आपण ठळकपणे पाहतो आहो आणि आपण ते कसे व्यवस्थापित करू शकतो हे पाहणार आहोत. परंतु नंतर त्या शोध भागाला अगदी सहजपणे व्यवस्थापित करणे शक्य आहे आणि हे कोणत्याही खेळासाठी स्वतंत्र आहे आणि आपण ह्या नंतरच्या मॉड्यूल्समध्ये त्यावर लक्ष केंद्रित करू. उघड आहे की खेळाच्या फायद्याचे संरचित नियम असतात जेंव्हा आपण तेथे असतो तेंव्हा आपण नियमाशिवाय त्या मोहर्याला हलवू शकत नाही. उदाहरणार्थ, आपल्याकडे एक हत्ती आहे, त्याच्या समोर आपला अजून एक प्यादा आहे आणि जोवर हा प्यादा समोर आहे मी ह्या हत्तीला पुढे हलवू शकत नाही. ठीक आहे, मला हा प्यादे हलवायचा आहे परंतू नियम असा आहे की मी ते करू शकत नाही. वजीराला वगळता इतर कोणताही मोहरा पुढे जाऊ शकत नाही. आपल्याला हे माहित आहे, की हा नियम आहे. ठीक आहे, तर, अर्थातच, तुम्ही हे मानता की खेळ खेळणे सोपे आहे. बुद्धीबळ कठीण आहे परंतु आपण एखादा साधा खेळ निवडला तर. अगदी टिक टॉक टोमध्ये झिरो आणि क्रॉस नॉट आणि क्रॉसदेखील प्रॉब्लेम आहे, हे देखील एवढे सोपे नाही. आपण यासाठी एखादा प्रोग्राम लिहिण्याचा प्रयत्न केला असेल तर आपल्याला कदाचित हे समजेल की त्यासाठी बर्याच गुंतागुंतीची आवश्यकता आहे. आणि आपण त्याबद्दलही बोलणार आहोत. या प्रकारच्या प्रॉब्लेमची एक मोठी समस्या अशी आहे की अनुक्रम आणि संयोजन खूपच मोठे आहे आणि दिलेल्या वेळेत संपूर्ण गेम ट्रीला एक्सप्लोर करणे आपल्यासाठी अशक्य आहे. हे देखील चांगले आहे, कारण जर आपण पूर्णपणे गेम ट्रीचा शोध घेत असाल तर कोणता मार्ग अनुसरण करायचा हे आपल्याला ठाऊक आहे. आणि एकदा तिथे पोहोचल्यावर तुम्ही जिंकलात. आपण जिंकणार आहात की नाही हे तुम्हाला ठाऊक असते आणि मग अशाप्रकारे खेळण्यात काही आकर्षण नाही. त्यामुळे गेम प्लेईंग प्रोग्राम्स मजेसाठी चांगले आहेत. चालू काळात, मोबाइल ॲंड मल्टी एजेंट गेम्सलाच जास्त मागणी आहे. पण पुन्हा, एकदा जेंव्हा आपण या सर्वांचा अभ्यास करू, तुम्हाला कळेल की हा त्या खेळांसाठीही एक अत्यंत महत्त्वाचा घटक आहे. काही मुद्दे आहेत, विशेषतः एक मुद्दा जो मला प्रकर्षाने दाखवायचा आहे तो म्हणजे जर आपल्याकडे एक मल्टी एजेंट गेम असल्यास, मल्टी प्रॉब्लेमशी संबंधित बर्‍याच गुंतागुंती अस्तित्वात आहेत, ठीक आहे. उदाहरणार्थ, दोन कार्स रेस करत असतील तर. आता दोन खेळाडू रेस करतांना त्यांच्या कार चालवण्यासाठी समान लेन वापरू शकत नाहीत. तर ती पहिली गोष्ट, ठीक आहे. याला सिंक्रोनाइझेशन म्हणतात किंवा पार्क म्हटले जाते, दोघेही एकाच ठिकाणी कार पार्क करू शकत नाहीत. तर, ही एक प्रॉब्लेम आहे ज्याची आपण चर्चा करणार आहोत, त्यापेक्षा जास्तीची आहे, परंतु अन्यथा सर्व पारंपारिक खेळ खेळण्याचे मुद्दे आहेत आणि आपण ज्यावर चर्चा करणार आहोत त्या सर्वांसाठी ते संबंधित आहे. स्वीकार्य चाल जनरेटर ज्याविषयी मी बोललो होतो, आठवा, आम्ही म्हटल्याप्रमाणे आपल्याकडे जवळ जवळ शंभरएक चाली आहेत आणि त्यापैकी आपण फक्त दहावर लक्ष केंद्रित करणार आहोत. आता हे सारे देखील विशिष्ट नाही. हे देखील खूपच गतिमान आहे. डायनॅमिक या अर्थाने की तो बर्‍याच गोष्टींवर अवलंबून आहे, मग तो खेळाचा प्रारंभिक भाग असो किंवा शेवटचा भाग असो. सामान्यतः प्रारंभिक भाग असो किंवा शेवटचा भाग होण्यापूर्वी आपल्याला प्लॉझिबल मूव्ह जनरेटरबद्दल जास्त काळजी करण्याची आवश्यकता नसते परंतु मधल्या भागासाठी आवश्यक आहे. दुसरे म्हणजे खेळाची समालोचना. समजा तुमच्या राजावर हल्ला झाला आहे. जर राजावर आक्रमण होत असेल तर आपल्याला बर्याच चालींचा विचार करावा लागेल. आपण फक्त दहावर लक्ष केंद्रित करू शकत नाही आपल्याला त्यासाठी जास्तीत जास्त चाली बघाव्या लागतील, ही स्थिती गंभीर आहे आणि असेच पुढेही. तर, असे अनेक प्रश्न आहेत जे तुम्हाला हे ठरवू देते की कोणत्या प्रकारच्या प्लॉझिबल मूव्ह जनरेटरचा उपयोग करावा लागेल आणि किती डेन्स ते निर्माण करते. स्पार्स नेबरहुड आणि डेंस नेबरहुडबद्दलची आपली चर्चा लक्षात घ्या. येथे पीएमजीदेखील अशाच पद्धतीने कार्य करतो. सामान्यतः हे स्पार्स नेबरहुड वापरते परंतु गंभीर स्थितीत हे डेंस नेबरहुड फंक्शनचा उपयोग करते. पण ठीक आहे, तेथे एक महत्वाची गोष्ट आहे जी मला प्लॉझिबल मूव्ह जनरेटर आणि लिगल मूव्ह जनरेटरमधील फरक देखील प्रकर्षाने पुढे करू इच्छित आहे. लिगल मूव्ह ही वैध आहे कारण आपण ती खेळू शकतो. परंतु प्लॉझिबल मूव्ह ही एक मान्य चाल आहे परंतु ती कोणत्याही फायद्याची नाही. आपण हे शोधणार नाही. उदाहरणार्थ, पुढे जाणे ही वैध चाल आहे परंतु ही आपल्या केसमधे काहीच कामाची नाही तर मग ही खेळण्यात काय अर्थ आहे. तर प्लॉझिबल मूव्ह जनरेटर त्या चालींचा शोध घेणार नाही. म्हणून सर्व संभाव्य चाली ह्या वैध वैध चाली आहेत. प्लॉझिबल मूव्हज् केवळ त्या चाली आहेत ज्या सद्य परिस्थितीत अर्थपूर्ण ठरतात. विनिंग मूव्ह नावाची आणखी एक चाल आहे. विनिंग मूव्ह आपल्याला विजयाकडे घेऊन जाते. आता ही एक महत्वाची श्रेणी आहे कारण आपल्याला हे इप्सित आहे की त्या प्लॉझिबल मूव्हज् जनरेटर्समधून विनिंग मूव्हज् अंमलात आणायच्या आहेत. प्लॉझिबल मूव्हज् ह्या पराभवाचे कारण होऊ शकतात. आपण प्लॉझिबल मूव्ह जनरेटरच्या यादीमधून एक चाल निवडू शकतो परंतु अखेरीस आपण हरतो. हे शक्य आहे . पण विनिंग मूव्हज् ही एक अशी गोष्ट आहे जो पुन्हा, एक उपसंच आहे. तर वैध चाली , त्यानंतर त्याचे उपसंच म्हणजे प्लॉझिबल मूव्ह , ज्यातील उपसंच विनिंग मूव्हज् आहेत. प्लॉझिबल मूव्ह जनरेटरचा फायदा हा आहे की आपण अधिक सखोल जाऊ शकतो कारण जर आपल्याकडे विचार करण्यायोग्य शंभरएक चाली असतील आणि आपण पाच मिनिटे किंवा सहा मिनिटे किंवा थोडा वेळ असेल तर आपल्याकडे एक्सप्लोर करण्यासाठी शंभर पर्याय आहेत. आपण जास्त खोलवर जाऊ शकत नाही. जर ते दहा पर्यंत कमी झाले तर आपण थोडे जास्त खोलवर जाऊ शकतो. व्यावसायिक बुद्धिबळाचे प्रोग्राम्स पंधरा, वीस प्लाईजपर्यंत , पंधरा वीस लेव्हल्सपर्यंत खोल जातात. आता ही एक मोठी गोष्ट आहे, ठीक आहे, कारण त्यांनी हा प्लॉझिबल मूव्ह जनरेटर वापरला आहे. जर प्लॉझिबल मूव्ह जनरेटर वापरला नाही तर बहुदा हे दोन तीन लेव्हल्स किंवा कमाल पाचपर्यंत जाऊ शकतो. आणखी एक मनोरंजक गोष्ट म्हणजे मी खेळाच्या सुरुवातीच्या आणि शेवटच्या भागाबद्दल बोलत होतो. पुन्हा एकदा आपल्याकडे बुद्धिबळासहित बहुतेक खेळांमध्ये वेळेची मर्यादा असल्यामुळे आपण त्या भागांना लवकर संपवू इच्छितो, प्रारंभिक भाग आणि नंतरचा भाग जो आपण एक सोपी युक्ती करून खेळू शकतो. आम्ही ठरवितो की दिलेल्या चालीतील ही सर्वात चांगली चाल आहे आणि ती डेटाबेसमध्ये संग्रहित आहे. आपण असे काहीही करत नाही, आपण शोध लागू करत नाही, आपण ह्यूरिस्टिक आणि काहीही लागू करत नाही. आपण जाणतो की जर खेळाडू आणि जर बुद्धीबळ चॅम्पियन्स खेळाचा प्रारंभिक भाग खेळतात पाहिले आहे, तुम्ही बहुदा पाहिले असेल की ते इतक्या जलदपणे खेळतात. ते त्यांचे मोहरे फार जलद गतीने पुढे सरकवतात, ते त्या क्रिया अधिक जलद करू इच्छितात कारण प्रारंभिक गेममध्ये आपल्याला माहित असते की जर प्रतिस्पर्धी हे खेळत असेल तर मला ते खेळायला लागेल आणि असेच पुढेही. हे फार क्लिष्ट नाही. तर ती गोष्ट एका डेटाबेसमध्ये संग्रहित केली आहे. तर, प्रारंभिक भागाला डेटाबेसमध्ये संग्रहित केले जाते आणि त्या गोष्टीला पुस्तकी चाली म्हणून ओळखले जाते, ठीक आहे. ती चाल डेटाबेसमध्ये संग्रहित केली आहे. म्हणून जेव्हा प्रतिस्पर्धी हे खेळतो तेव्हा आपण त्या गोष्टींना केवळ डेटाबेसशी जुळवतो आणि जनरेट करतो. पुस्तकी चाली खूप जास्त असू शकतात. मग एक फायदा पण आहे, ठीक आहे. आपण फक्त या सर्व शोधाला पुढे नेतो आणि दुसरी गोष्ट कार्य करते. ही बुद्धिबळाच्या सुरूवातीस आणि शेवटच्या भागासाठी बरीच उपयुक्त आहे आणि त्यापैकी बहुतेकाचा प्रत्यक्षात वापर केला जातो. आपण गेमच्या मधल्या भागात पुस्तकी चाली वापरू शकत नाही कारण आपल्याला ठाऊक आहे की आपल्याजवळ खेळात प्रशाखी घटक म्हणून सरासरी पस्तीस असते आणि एक खेळाडू सरासरी एका खेळात पन्नास चाली खेळतो. दोन्ही खेळाडूंचा विचार करता आपल्याकडे एकूण पसतीस घातांक शंभर संभाव्य चाली आहेत. आता आपण रिअल टाइममध्ये ती सर्च स्पेस शोधू शकत नाही. तर ते आपल्यासाठी अशक्य आहे. किंवा आपण ते साठवू देखील शकत नाही. आपल्याकडे तो संग्रहित करण्यासाठी (|डेटाबेस|database)) देखील नाही. शेवटचा (|डेटाबेस|database)) साध्य करणे जवळजवळ अशक्य आहे. आणि त्या (|डेटाबेसमध्ये|database)) शोधणे देखील खूप महाग आहे. तर, हे अगदी अशक्य आहे. म्हणून आपण मधल्या खेळात बुक मूव्हज् वापरू शकत नाही. त्या केवळ गेमच्या सुरूवातीस आणि शेवटी वापरल्या जातात. ठीक आहे मी म्हटल्याप्रमाणे येथे आणखी एक गोष्ट स्थिर मूल्यांकन फंक्शन नावाच्या ह्यूरिस्टिक फंक्शनचा उपयोग केला जातो. आपण हे करतो की दिलेल्या बिंदूपासून जितके दूर होईल ट्री शोधून काढतो आणि परत येऊन एक चाल निवडतो. समजा आपल्याकडे चार भिन्न पर्याय आहेत, आपण प्रत्येकाचा शोध घेण्याचा प्रयत्न करतो, आणि शोधतो की ते काय देते नंतर सगळ्यात उत्कृष्ट नोड निवडतो. ही सर्वसाधारण प्रोसेस आहे. आता आपण गेम प्लेईंग प्रोग्रॅम्सच्या इतिहासाबद्दल थोडेसे बोलू या. क्लाउड शॅननने एकोणीसशे पन्नासमधे गेम प्लेईंग प्रोग्रॅम्सबद्दल सांगितले होते आणि त्यानंतर अ‍ॅलन ट्युरिंगने देखील सांगितले की चेस प्लेईंग प्रोग्राम तयार करणे आणि त्या प्रोग्रॅमचे वर्णन देणे देखील शक्य आहे. त्याने ते स्वतः बनवण्याचा प्रयत्न केला नाही. सॅम्युएल्सने एकोणीस साठमध्ये चेकर्स प्रोग्राम बनविला. आणि तो चेकर्स प्रोग्राम ड्राफ्ट गेम किंवा चेकर्स गेम खेळत असे. कुणी गेम प्लेईंग प्रोग्राम कसा डिझाइन करू शकतो याचे हे एक चांगले उदाहरण होते. त्या प्रोग्रामची स्वतःहून व अनुभवातून शिकण्याची विशेष क्षमता होती. हे अखेरीस इतके चांगले झाले की त्याने स्वत: खरोखरच शोधकर्त्या सॅम्युएललाच हरवले. बर्याच आधी एकोणीसशे एकोणीस साली आईबीएमचे एक संगणक डीप थॉटने तत्कालीन ऑलिम्पिक चॅम्पियन रिचर्ड लेवीचा पराभव केला. त्यानंतर एकोणीसशे शहाण्णवमधे डीप ब्लूने गॅरी कॅस्पॅरोव त्यानेळेच्या वर्ल्ड चॅम्पियनला तीन दोनच्या फरकाने पराभूत केले. ते पाचदा खेळले, गॅरी कॅस्पॅरोव्हने दोन, आणि डीप थॉट टूने तीन गेम जिंकले, आणि त्यानंतर एक्स थ्री डी फ्रिट्झ नावाचा आणखी एक प्रोग्राम होता. हे गॅरी कॅस्पॅरोव्हबरोबर अलीकडेच दोन हजार तीनमध्ये खेळले, तुलनात्मकदृष्ट्या अलीकडेच, ही तेरा वर्षांपूर्वीची गोष्ट आहे. परंतु इतरांच्या तुलनेत ते अद्यापही अलीकडचेच आहे. तर तो गॅरी कॅस्पॅरोव्हसोबत तो सामना अनिर्णित राहीला. तर हे पुन्हा एक उत्कृष्ट उदाहरण होते. तर हे इतिहासजमा आहे. स्टॅनफोर्ड युनिव्हर्सिटीला इवढी आवड आहे, ते एक प्रोग्राम चालवित आहेत, ते एक गेम प्लेईंग व्यासपीठ उपलब्ध करवतात जिथे लोक त्या व्यासपीठाचा वापर स्वतःचे खेळ तयार करण्यासाठी करू शकतात. आणि मग ते स्पर्धा करतात आणि ते दोन हजार पाच पर्यंत ते एक स्पर्धा चालवित होते, जिथे लोक त्यांचे प्रोग्राम लिहू शकतात आणि आपला प्रोग्रामचे प्रदर्शन करवू शकतात आणि शेवटी स्पर्धेचे आयोजन करतात आणि त्या स्पर्धेचे विजेते घोषित करतात आणि असेच बरेच काही. आता बरेच मल्टी एजेंट गेम्स इंटरनेटवरही आहेत. परंतु आपण पुढे जाण्यापूर्वी आपण आणखी एका महत्त्वपूर्ण गोष्टीकडे लक्ष ठेवले पाहिजे. आपल्याला कोणत्या प्रकारच्या खेळांबद्दल गोष्टी करण्यात आवड आहे? खेळांचे वर्गीकरण करण्याचे काही मार्ग आहेत. आमच्याकडे एकल व्यक्ती खेळ आहे, सॉलिटेअर हे एक उदाहरण आहे. बुद्धीबळ हा दोन-व्यक्तींचा खेळ आहे. मल्टी पर्सन गेम, मल्टी प्लेयर गेम, कार रेसिंग हे त्याचे उदाहरण आहे. फरक करण्याचा हा एक मार्ग आहे. आणखी एक मार्ग म्हणजे खेळ झिरो सम आहे की नाही. झिरो सम गेम हा असा खेळ आहे ज्यात एकाचा फायदा म्हणजेच दुसर्याचे नुकसान असते. म्हणून मला काही मिळाले तर दुसरा कोणी हरेल. पत्त्यांचे खेळ बरेचसे असे असतात. जर मला अधिक डाव मिळाले इतरांना कमी मिळतील. ठीक आहे, म्हणून अशा खेळांना झिरो सम गेम असे म्हणतात. काही खेळांमध्ये, तसे नसते. उदाहरणार्थ, कार रेसिंगमध्ये, जर मी कोणा दुसर्‍या कोणाशी टक्कर मारली तर दोघेही आपापले गुण गमावतात, ठीक आहे. माझे नुकसान हा त्याचा फायदा नाही किंवा काही मार्केटिंग गेम्स आहे जिथे आपल्यातील बर्‍याच जणांना नफा मिळवणे शक्य आहे. जर सर्व काही ठीक असेल आणि प्रत्येकजण चांगले खेळत असेल तर त्या प्रत्येकास त्याचा लाभ मिळेल याचे हे एक उदाहरण आहे. तिसरा पद्धत म्हणजे फरक करण्याचा तिसरा मार्ग असा की खेळाबद्दल पूर्ण माहिती उपलब्ध आहे की नाही. पत्त्यांच्या खेळात आपल्याकडे पूर्ण माहिती नसते. आता आपणास कदाचित हे समजेल की हे एजेंट्सविषयीच्या चर्चेसारखेच आहे आणि ते खरे आहे. पूर्ण माहिती असलेल्या खेळांविषयी प्रोग्राम करणे सोपे आहे. अपूर्ण माहिती असलेल्या खेळांसाठी गृहीतक तयार करणे आवश्यक आहे आणि ती गृहीतक फेटाळायची असतात, ठीक आहे. यासाठी एनएसआरएस इत्यादींची आवश्यकता आहे ज्याबद्दल आपण बोललो आहे, त्या सर्व गोष्टी चित्रात येतील जे काळाच्या तसेच संग्रहणाच्या दृष्टीने अजिबात परवडणार्या नाही आहेत. ठीक आहे, संपूर्ण माहितीमध्ये पर्यावरण देखील समाविष्ट आहे. हे याविषयी सांगते ,उदाहरणार्थ, कार रेसिंग खेळामधे इतर लोक काय करतात ही माहिती देखील आपल्याकडे उपलब्ध असते. जर ते फक्त आपल्याकडे उपलब्ध असेल तर आपण कार रेसिंगमध्ये चांगले प्रदर्शन करू शकू. इतर काय करीत आहेत हे आपल्याला माहिती नसल्यास कदाचित आपण हे करू शकणार नाही. कदाचित आपली टक्कर होईल, लवकरच आपण दुसर्‍या कोणाशी टक्कर घेऊ. म्हणून जेव्हा मी म्हटल्याप्रमाणे पूर्ण माहिती असणारे खेळ तुलनात्मकदृष्ट्या चांगले असतात परंतू अर्धवट माहिती असणार्या खेळांमधे जेंव्हा संपूर्ण माहिती नसते म्हणून जेव्हा मी म्हटल्याप्रमाणे आपल्याला गृहीतकांची गरज असते. तर हे त्याला थोडे कठिण बनवते. फरक करण्याचा शेवटचा मार्ग म्हणजे तो निर्धारणात्मक आहे का. उदाहरणार्थ मी एक चाल खेळलो तर मी असे म्हणू शकतो का की जर मी ही चाल खेळलो तर मला हा परिणाम नक्कीच मिळेल? मला खात्री नसेल तर तो निर्धारणात्मक नाही. जर हे निश्चित असेल,तर ते निर्धारणात्मक आहे. उदाहरणार्थ, मी एक एट पझल खेळत आहे, मी एक घर खाली जातो, मला माहित आहे की खरोखर काय होईल किंवा माझ्याकडे काही चालाींची मालिका आहे, काही एक्शंस आहेत तर मी आऊटपुटची आता गणना करू शकतो आणि माझ्यापाशी तेच आऊटपुटची असेल जे बदलणारे नाही. कार ड्राइव्हिंग किंवा बुद्धीबळातही तुमच्याकडे ते असू शकत नाही. म्हणून हे निश्चित करण्याचे मुद्दे आहेत कारण बुद्धीबळात कार रेसिंगपेक्षा थोडाशी जास्त निर्धारणात्मकता असते. का? कारण केवळ प्रतिस्पर्ध्याला ती गोष्ट जाणण्याची आवश्यकता असते. पण आपल्या बाबतीत काय घडणार आहे ते आपल्याला ठाऊक आहे. जर प्रतिस्पर्धी तुमच्या त्या चालीनुसार खेळत नसेल तर तो भाग बदलेल. पण तुम्हाला माहीत आहे की जेव्हा मी एक मोहरा पुढे ठेवतो तेव्हा ते पुढे जाईल. ठीक आहे, तर तो भाग तुमच्या हातात आहे. तर तो भाग निर्धारणात्मक आहे. पण कारच्या बाबतीत असे नाही. कार रेसिंगमध्ये आपण प्रवेगक पेडल दाबता परंतु कदाचित ते काम करणार नाही कारण आपण आधीच अधिकतम मर्यादेपर्यंत पोहोचलेलो आहे. तर हे अजिबात निर्धारणात्मक नाही. इतकेच नाही, तुम्ही हे यामुळे देखील करू शकत नाही कारण यात पुष्कळसे इतर खेळाडू देखील सामील आहेत. तर ते निर्धारणात्मक नाही. अर्थात या प्रकरणात आपल्याला काही गृहितक स्वीकारावी लागतील. दोन खेळाडूंवाल्या खेळाच्या बाबतीत आपण येथे काय करणार आहोत किंवा आपल्या बाबतीत आपण दोन खेळाडूंवाला खेळ घेऊ. नंतरच्या सर्व मॉड्यूल्समधे आपण फक्त दोन खेळाडूं असणारा खेळ आणि संपूर्ण माहितीवाल्या खेळाचे गृहीतकांसह वर्णन करू. आपण तो भाग पाहणार नाही. तो भाग जरा क्लिष्ट आहे. मी सांगितल्याप्रमाणे आपल्याला त्या धारणा आणि त्या गोष्टींची आवश्यकता आहे. या गोष्टीच्या शेवटी जेंव्हा आपण मशीन लर्निंगबद्दल बोलू, तेंव्हा आपण हिडन मार्कोव्ह मॉडेलचा संदर्भ देऊ आणि पाहू की त्याच्याशी कसे परिचित होता येईल. म्हणून यावर आपण थोडा प्रकाश टाकू पण अन्यथा आपण अपूर्ण माहिती असणार्या खेळांकडे लक्ष देणार नाही आहोत, ठीक आहे. दोन खेळाडू असणार्या खेळाला कधीही अनेक एजेंट्समधे वाढवता येऊ शकते. मुद्दा केवळ सिंक्रोनाइझेशनचा आहे की ज्याविषयी मी बोललो होतो, त्याला जोडता येऊ शकते. आणि आपण असे गृहीत धरतो की दोन्ही प्रतिस्पर्ध्यांचे लक्ष्य पूर्णपणे एकमेकांच्या विरुद्ध आहेत. तर माझे जिंकणे हा दुसर्‍या व्यक्तीचा पराभव आहे आणि त्याचे जिंकणे माझा पराभव आहे, ठीक आहे. असे नाही की आम्ही दोघेही जिंकू शकतो आणि अशा परिस्थितीबद्दल आपण आता बोलत नाही आहोत. तर गेम ट्री हीच एक सर्च ट्री आहे परंतु नंतर पारंपारिक सर्च ट्रीसारखे नसून यात स्तर वेगळे असतात. पहिला स्तर जर मी घेत असेन तर मी पहिली चाल खेळत आहे, तर मी त्याला अधिकतम म्हणतो कारण मी माझ्या जिंकण्याच्या शक्यता अधिकतम करतो आहे. पुढील स्तर प्रतिस्पर्ध्याद्वारे खेळला जातो आणि माझ्या जिंकण्याच्या शक्यतांना कमी करतो. पुन्हा, पुढच्याच्या पुढचा स्तर माझे स्वतःचे स्थान आहे जिथे मी जिंकण्याची शक्यता अधिकतम करतो आहे. म्हणूनच त्यांना न्यूनतम-अधिकतम स्तरदेखील म्हटले जाते. अधिकतम स्तर तो स्तर आहे जेथे खेळाडू खेळतो आणि न्यूनतम स्तर तो असतो जेथे प्रतिस्पर्धी खेळतो. म्हणून अनेक परिणाम असू शकतात. टीक टॉक टोच्या केसमध्ये तीन संभाव्य परीणाम होतात, जिंकणे, हरणे आणि अनिर्णित. तर टीक टॉक टो हा स्क्रीनवर दर्शविला गेला आहे. जिंकण्याचे आठ वेगवेगळे मार्ग आहेत. आपल्याला जे प्राप्त करायचे आहे ते सलग तीन सेल आहेत आणि आपण त्यांना चिन्हांकित केले आहे. आणि तुम्ही पाठोपाठ तीन सेल चिन्हांकित केल्यास तुम्ही जिंकलात. तर स्क्रीनवर जिंकण्याचे आठ वेगवेगळे मार्ग दाखवले आहेत आणि तेथे आणखी एक आकृती आहे जी संपूर्ण सर्च ट्रीचे वर्णन करते. नॉट कंप्लीट हा देखील एक लहान उपसंच आहे आणि आपण याच्या प्रत्येक गोष्टीत प्रत्येक चाइल्डचा शोध घेत नाही. आपण प्रत्येक स्तरात फक्त एका चाइल्डचा शोध घेत आहोत, अर्थातच स्क्रीनवर असलेल्या जागेच्या मर्यादेमुळे. परंतु या केसमधे स्पेसची मर्यादा नसली तरी एक मोठी गोष्ट होणार आहे, परंतु नंतर त्या स्टेट्सला बघा ज्याभोवती वर्तुळ काढली आहेत. ठीक आहे, एक दोन, आणि एक काहीतरी आहे W नावाचे, आणखी एकाला L म्हणतात. आता ह्या वनमधे आपण हे पाहू शकता की माझ्याजवळ त्याच ओळीत दोन X आहेत परंतु नंतर तेथे शून्य खेळले गेले आहे, ठीक आहे. आणि दुसरीकडे आपल्यापाशी लाईनीत दोन X आहेत जिथे शून्य इतरत्र खेळले केले आहे. आता या दोघांमध्ये काय फरक आहे? जेव्हा दोन X एका ओळीत असतात आणि जेव्हा शून्य पुढे असतो तेव्हा मी त्या व्यक्तीला जिंकण्यापासून अडवू असतो आणि जेव्हा मी शून्य इतर कोठेही खेळतो तेव्हा मी त्याला अडवत नाही. मी माझा पराभव सुनिश्चित करतो आहे. तर, ते असे होते जिथे आपण पाहू शकतो की हे त्या माहितीचा आधारे जिंकणे किंवा हारणे याचा परिणाम आहे, ठीक आहे. तर, W जिंकत आहे. आपण पाहू शकता की सर्व तीन X एका ओळीत आहेत जेणेकरून आपण जिंकतो आणि जेव्हा तीन शून्य क्रमवारीत असतात तेव्हा आपण हरत असतो. तर, एक आहे W, म्हणजेच एका अशा स्टेटपर्यंत आपण पोहचू इच्छितो जो W आहे आणि आपण त्या स्टेटला टाळण्यास इच्छुक आहोत ची L आहे, जर आपल्याला W मिळत नसेल तर आपण D ने समाधानी होऊ शकतो, जे बाद झाला आहे. या विशिष्ट केसमध्ये, आपण पाहू शकता की हे शक्य आहे आणि कारण तो एक छोटासा प्रोग्राम आहे, प्रॉब्लेम स्पेस आहे, वास्तविक स्टेट स्वतः, त्या सर्वांना अनिर्णित ठेवू शकतो. बुद्धीबळाच्या बाबतीतही मी हे अनिर्णितही ठेवू शकत नाही. परंतु आपण सहजपणे समजू शकता की येथे तीन संभाव्य परिणाम आहेत-जिंकणे, पराभव आणि अनिर्णितता. तर, आपण पाहू शकता की अशा काही केसेस आहेत जिथे कोणीही जिंकत नाही. त्यापैकी कोणालाही ती गोष्ट अनुक्रमे मिळत नाही. तर, तो एक ड्रॉप आहे आणि दुसर्‍या खेळाडूसाठी तीन कमी निवडी आहेत ज्या आपण देखील पाहू शकता. आणि आता आपण या विशिष्ट मॉडेलचा शेवट करू. या मॉड्यूलमध्ये आपण काय पाहिले? आपण नुकतेच खेळ खेळण्याबाबत बोलण्यास सुरुवात केली आहे. आपण काही सिद्धांत पाहिले आहेत आणि आपण स्वीकार्य चाल जनरेटर पाहिले आहे, आपण स्टॅटिक इव्हॅल्यूएशन फंक्शनबद्दल बोललो आहो, आपण गेम प्लेईंग ॲल्गोरिदम्सच्या इतिहासाकडे पाहिले, आपण शोध प्रक्रियेकडे पाहिले आहे ज्यासाठी न्यूनतम और अधिकतम स्तर आवश्यकता आहे. अधिकतम स्तर प्रतिस्पर्धी खेळत असतो न्यूनतम स्तर प्रतिस्पर्धी खेळत आहे, हे खेळाडूची जिंकण्याची शक्यता कमी करेल. आणि या नोटसह आपण हे सत्र समाप्त करू, परंतु त्यानंतरच्या मॉड्यूल्सची ही पूर्वस्थिती असेल जिथे आपण थोडे अधिक खोलात खेळण्याबद्दल शिकत आहोत. धन्यवाद .
